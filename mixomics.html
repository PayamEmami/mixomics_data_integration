<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Payam Emami">

<title>Matrix Decomposition for Data Integration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="mixomics_files/libs/clipboard/clipboard.min.js"></script>
<script src="mixomics_files/libs/quarto-html/quarto.js"></script>
<script src="mixomics_files/libs/quarto-html/popper.min.js"></script>
<script src="mixomics_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="mixomics_files/libs/quarto-html/anchor.min.js"></script>
<link href="mixomics_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="mixomics_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="mixomics_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="mixomics_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="mixomics_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Matrix Decomposition for Data Integration</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Payam Emami </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p>Setup the environment</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-1_af85c81e4835b659854cb7e1c418a143">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of packages to be installed</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>packages <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"mixOmics"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Check and install missing packages</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>new_packages <span class="ot">&lt;-</span> packages[<span class="sc">!</span>(packages <span class="sc">%in%</span> <span class="fu">installed.packages</span>()[,<span class="st">"Package"</span>])]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="fu">length</span>(new_packages)) <span class="fu">install.packages</span>(new_packages, <span class="at">dependencies =</span> <span class="cn">TRUE</span>, <span class="at">type =</span> <span class="st">"binary"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the libraries</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mixOmics)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In classical data integration, we would like to use information across different modalities (eg., transcriptome, proteome and metabolome) to gain more comprehensive insights into the biological systems under study. This type of data can be used for an array of different purposes including but not limited to molecular classification, stratification of patients, outcome predictions and understanding of regulatory processes such as gene regulation and pathway aAnalysis.</p>
<p>In this specific context, we are going to focus on outcome prediction modeling and segmentation, which are promising because each type of omics data may contribute valuable information for the prediction of phenotypic outcomes. More specifically we are going to focus on supervised and unsupervised data integration wherein we have obtained patient data for which several types of omics data are available for the same samples (e.g.&nbsp;patients).</p>
<p>In this lab we are going to learn about matrix decomposition and how it can be used to integrate multimodal data. Matrix decomposition provides us with simple yet powerful tool to explore our data and extract meaningful information from it. Matrix decomposition techniques, such as Singular Value Decomposition (SVD) allow us to break down a complex matrix into simpler, more manageable components. These components can then be analyzed to uncover underlying patterns, trends, and structures within the data. We are going to revisit PCA and look at generalized canonical correlation analysis (GCCA) including partial least squares discriminant analysis (PLS-DA) and its multiomics expantion.</p>
</section>
<section id="pca" class="level1">
<h1>PCA</h1>
<p>PCA is a special case of SVD in which basis vectors, or principal components, are the eigenvectors of the data’s covariance matrix. These principal components are orthogonal and represent the directions of maximum variance in the data. If you want to know more about PCA look at <a href="http://payamemami.com/pca_basics/" title="PCA basics">here</a>.</p>
<p>Principal Component Analysis (PCA) might sound complex at first, but it can be understood intuitively as a method for simplifying and summarizing complex, multidimensional data.</p>
<p>Given a dataset containing the expression levels of thousands of genes from a group of individuals. Each individual is a complex data sample characterized by the expression of all these genes. Visualizing or analyzing such high-dimensional data can be very difficult.</p>
<p>PCA simplifies this complex, multidimensional space by identifying the “principal components” of the data, which are new axes that capture the most significant patterns in the data. These axes are combinations of the original gene expression levels that explain the maximum variance in the dataset.</p>
<p>For example, the first principal component (PC) might represent a combination of genes that change the most across all individuals. It could capture a general trend in gene expression that separates individuals based on age or response to a treatment. The second PC (orthogonal to the first), might capture the next highest variance, showing another layer of structure in the data, and so on.</p>
<p>Formally,PCA is derived from the right singular vectors contained in matrix <span class="math inline">\(V\)</span>. The singular values in <span class="math inline">\(\Sigma\)</span> are related to the eigenvalues of the covariance matrix of the original data, and they indicate the amount of variance captured by each principal component.</p>
<p>In simpler terms, when we perform SVD on a data matrix <span class="math inline">\(A\)</span>, the columns of <span class="math inline">\(V\)</span> (the right singular vectors) are actually the principal components of <span class="math inline">\(A\)</span>. The singular values in <span class="math inline">\(\Sigma\)</span> tell us the importance or weight of these principal components.</p>
<p>The SVD of a matrix <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span> is expressed as: <span class="math display">\[
A = U \Sigma V^T
\]</span> where</p>
<p>- <span class="math inline">\(U \in \mathbb{R}^{m \times m}\)</span> is the left singular matrix,</p>
<p>- <span class="math inline">\(\Sigma \in \mathbb{R}^{m \times n}\)</span> is the diagonal matrix containing the singular values, and</p>
<p>- <span class="math inline">\(V \in \mathbb{R}^{n \times n}\)</span> is the right singular matrix.</p>
<p>To see this connection clearly, let’s consider the covariance matrix of <span class="math inline">\(A\)</span>, denoted as <span class="math inline">\(C\)</span>: <span class="math display">\[
C = \frac{1}{n-1} A^T A
\]</span></p>
<p>When we perform eigen decomposition on <span class="math inline">\(C\)</span>, we get: <span class="math display">\[
C = W \Lambda W^T
\]</span> where <span class="math inline">\(W\)</span> contains the eigenvectors and <span class="math inline">\(\Lambda\)</span> is a diagonal matrix containing the eigenvalues.</p>
<p>Now, if we look at the SVD of <span class="math inline">\(A\)</span> again: <span class="math display">\[
A = U \Sigma V^T
\]</span> and compute <span class="math inline">\(A^T A\)</span>, we get: <span class="math display">\[
A^T A = V \Sigma^T U^T U \Sigma V^T = V \Sigma^2 V^T
\]</span></p>
<p>Comparing this with the eigen decomposition of <span class="math inline">\(C\)</span>, we observe that the right singular vectors <span class="math inline">\(V\)</span> are the eigenvectors of <span class="math inline">\(C\)</span>, and the singular values squared in <span class="math inline">\(\Sigma^2\)</span> are the eigenvalues in <span class="math inline">\(\Lambda\)</span>.</p>
<section id="section" class="level4">
<h4 class="anchored" data-anchor-id="section"></h4>
<p>There are other algorithms for doing PCA for example using power methods but almost all of them will converge to the same solution with a certain numerical accuracy.</p>
</section>
<section id="pca-in-practice" class="level2">
<h2 class="anchored" data-anchor-id="pca-in-practice">PCA in practice</h2>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>Our data has to be in a data.frame where features are in the columns and samples in the rows. For now we are going to use TCGA dataset from mixOmics.</p>
<blockquote class="blockquote">
<p><em>This data set is a small subset of the full data set from The Cancer Genome Atlas that can be analysed with the DIABLO framework. It contains the expression or abundance of three matching omics data sets: mRNA, miRNA and proteomics for 150 breast cancer samples (Basal, Her2, Luminal A) in the training set, and 70 samples in the test set. The test set is missing the proteomics data set.</em></p>
</blockquote>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-2_47ecf9b6b2a6e53602fb6f534020a26c">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Download the dataset</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">download.file</span>(<span class="st">"https://github.com/mixOmicsTeam/mixOmics/raw/master/data/breast.TCGA.rda"</span>, <span class="at">destfile =</span> <span class="st">"TCGA.rda"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># load the data</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"TCGA.rda"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This data has already been split into a list with two elements. Training and testing. Each element itself is a list of four elements. Three elements are the actual datasets and one is the cancer subtypes.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-3_32dc5218c3d3bab5bed5a04105e2b270">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(breast.TCGA)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>List of 2
 $ data.train:List of 4
  ..$ mirna  : num [1:150, 1:184] 11.8 12.9 12.3 12 13.4 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:150] "A0FJ" "A13E" "A0G0" "A0SX" ...
  .. .. ..$ : chr [1:184] "hsa-let-7a-1" "hsa-let-7a-2" "hsa-let-7a-3" "hsa-let-7b" ...
  ..$ mrna   : num [1:150, 1:200] 4.36 1.98 1.73 4.36 2.45 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:150] "A0FJ" "A13E" "A0G0" "A0SX" ...
  .. .. ..$ : chr [1:200] "RTN2" "NDRG2" "CCDC113" "FAM63A" ...
  ..$ protein: num [1:150, 1:142] 0.0491 -0.08 -0.0328 -0.2053 0.0602 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:150] "A0FJ" "A13E" "A0G0" "A0SX" ...
  .. .. ..$ : chr [1:142] "14-3-3_epsilon" "4E-BP1" "4E-BP1_pS65" "4E-BP1_pT37" ...
  ..$ subtype: Factor w/ 3 levels "Basal","Her2",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ data.test :List of 3
  ..$ mirna  : num [1:70, 1:184] 12.8 13.9 12.9 12.4 13.1 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:70] "A54N" "A2NL" "A6VY" "A3XT" ...
  .. .. ..$ : chr [1:184] "hsa-let-7a-1" "hsa-let-7a-2" "hsa-let-7a-3" "hsa-let-7b" ...
  ..$ mrna   : num [1:70, 1:200] 1.19 2.73 3.05 2.7 3.14 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:70] "A54N" "A2NL" "A6VY" "A3XT" ...
  .. .. ..$ : chr [1:200] "RTN2" "NDRG2" "CCDC113" "FAM63A" ...
  ..$ subtype: Factor w/ 3 levels "Basal","Her2",..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
</div>
</div>
</section>
<section id="pca-in-r" class="level3">
<h3 class="anchored" data-anchor-id="pca-in-r">PCA in R</h3>
<p>Doing PCA in R using SVD is straight forward. We should just center our data and use the <code>svd</code> function.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-4_dda584e723340fada711bbd03052f26d">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>data_centered_mirna <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna,<span class="at">center =</span> <span class="cn">TRUE</span>,<span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># do SVD</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>svd_mirna <span class="ot">&lt;-</span> <span class="fu">svd</span>(data_centered_mirna)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the PC scores</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>calculated_scores <span class="ot">&lt;-</span> data_centered_mirna<span class="sc">%*%</span>svd_mirna<span class="sc">$</span>v</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the PC scores</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(calculated_scores[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>],<span class="at">xlab=</span><span class="st">"pc1"</span>,<span class="at">ylab=</span><span class="st">"pc2"</span>,<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This will give us identical results comapred to the for example standard <code>prcomp</code> function</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-5_d124fe98e4aa1e7d6815c3e333498d44">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># do pca using prcomp</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>pca_prcomp <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(data_centered_mirna)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the PCA</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(pca_prcomp<span class="sc">$</span>x[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>],<span class="at">xlab=</span><span class="st">"pc1"</span>,<span class="at">ylab=</span><span class="st">"pc2"</span>,<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In practice there are more specialized packages that can be used to do PCA. <code>mixOmics</code> provides a very powerful PCA method that provide us not only with standard PCA but also with extra advantange (eg., missing value handling, plotting, handling repeated measurements etc).</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-6_0de052cac2b01c2c9b6b97271cad6f3f">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># do pca using prcomp</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>pca_mixomics <span class="ot">&lt;-</span> mixOmics<span class="sc">::</span><span class="fu">pca</span>(data_centered_mirna,<span class="at">ncomp =</span> <span class="dv">2</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the PCA</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>mixOmics<span class="sc">::</span><span class="fu">plotIndiv</span>(pca_mixomics,<span class="at">group=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">ind.names =</span> F,<span class="at">legend =</span> T,<span class="at">title =</span> <span class="st">"miRNA PCA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the function above, we have performed a PCA with two components on miRNA data. The first principal component (PC1) captures 23% of the total variance, while the second principal component (PC2) accounts for an additional 9%. This means that together, PC1 and PC2 provide a simplified representation that encapsulates 32% of the total variability in the gene expression data.</p>
<p>Examining the PCA plot, you’ll notice distinct patterns. The Basal group is clustered on the right side of the plot, indicating a unique gene expression profile that is markedly different from the other subtypes. In contrast, the HER2 and LumA subtypes are more centered and somewhat intermingled towards the left, suggesting overlapping or similar patterns of gene expression. Most of the differences are represented in the PC1. So it is probably our most important factor to focus on!</p>
<p>This observed separation and overlap in the PCA plot is not just a graphical representation but is rooted in the underlying biology of these cancer subtypes. The positioning of the different groups on the PCA plot is influenced by the expression levels of various miRNAs, each contributing differently to the principal components.</p>
<p>Now, as we go deeper into understanding the PCA plot, it becomes essential to explore the concept of <code>loadings</code>. Loadings help us interpret the contribution of each miRNA to the principal components. They provide insights into which specific miRNAs are driving the separation between different cancer subtypes observed in the PCA plot.</p>
<p>We can go ahead and plot the loadings. We start with our most important PC, that is PC1</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-7_dc361139e81537f24e05648182efa617">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># loadings for component 1</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>mixOmics<span class="sc">::</span><span class="fu">plotLoadings</span>(pca_mixomics,<span class="at">comp =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In this bar plot, each bar represents a specific miRNA. The length of the bar corresponds to the value of the loading of that miRNA on PC1, indicating its contribution to this principal component. The miRNAs with the highest absolute contributions are at the bottom, and those with the lowest are at the top, making it easy to identify the most influential miRNAs. Both the length and direction of each bar provide crucial insights into the miRNA’s contribution to the first principal component (PC1). The length of the bar signifies the magnitude of the miRNA’s contribution. Longer bars indicate miRNAs that have a more substantial influence on the variance captured by PC1, highlighting them as key elements in distinguishing different patterns of gene expression within the dataset.</p>
<p>The direction of the bars adds another layer of interpretation. Bars extending to the right represent miRNAs that are positively correlated with PC1, indicating that as the values of these miRNAs increase, so does the score of PC1. Conversely, bars extending to the left suggest a negative correlation, meaning as the values of these miRNAs increase, the score of PC1 decreases. This directional information can be important in understanding the expression patterns of miRNAs in different breast cancer subtypes. For instance, miRNAs that are positively correlated with PC1 might be highly expressed in the Basal subtype but low in others, offering insights into the molecular distinctions between these cancer subtypes.</p>
<p>Score plot together with loading give us powerful tool to investiage pattern in a single dataset. But how about if we have multiple datasets? Can we simply go ahead and merge multiple datasets into one and do PCA on this merged data?</p>
<p>While it might be tempting to merge multiple datasets into one and proceed with PCA, this approach has several challenges and limitations. Different datasets can have variations in terms of units, scales, and data collection methods. Simply merging them without addressing these issues can lead to misleading PCA results, where the observed variance is more a reflection of the datasets’ inconsistencies rather than underlying biological patterns. In addition, when datasets are collected at different times, locations, or under different conditions, batch effects can occur. These systematic non-biological differences can confound the PCA results, making it difficult to detect true patterns and relationships within the data. This leads us to multi-omics analysis, where techniques like Canonical Correlation Analysis (CCA) become offer ways to detect correlated patterns between two or more omics datasets, and providing a more holistic view of the underlying biological processes.</p>
</section>
</section>
</section>
<section id="cca-two-datasets" class="level1">
<h1>CCA (two datasets)</h1>
<p>Canonical Correlation Analysis (CCA) is similar to PCA with the capability to analyze multivariate correlations between two datasets. While PCA focuses on maximizing variance within a single dataset, CCA identifies linear combinations of variables from two datasets that are maximally correlated. It provides pairs of canonical variables and their associated canonical correlations, giving insights into the shared structure and relationships between datasets. This is particularly suited in multi-omics studies, where understanding the interplay between different types of biological data is crucial.</p>
<section id="mathematical-foundations" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-foundations">Mathematical Foundations</h2>
<p>CCA seeks to find pairs of linear combinations, one from each dataset, that are maximally correlated. If we have two datasets <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, the canonical correlations are obtained by solving the optimization problem:</p>
<p><span class="math display">\[
\max_{a, b} \rho = \text{corr}(a^T X, b^T Y)
\]</span></p>
<p>where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are the canonical weights, and <span class="math inline">\(\rho\)</span> is the canonical correlation.</p>
<p>The cross-covariance matrix between <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> plays a central role in calculating CCA weights. We compute it and then apply SVD to find the weights and correlations. The process is similar to performing SVD in PCA but extends to exploring relationships between two datasets.</p>
<p><span class="math display">\[
\text{SVD}(\Sigma_{XY}) = U \Lambda V^T
\]</span></p>
<p>where <span class="math inline">\(\Sigma_{XY}\)</span> is the cross-covariance matrix, <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are the canonical weights for <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, and <span class="math inline">\(\Lambda\)</span> contains the canonical correlations.</p>
<p>We can now find the canonical variables:</p>
<p><span class="math display">\[
T_x = XU
\]</span> <span class="math display">\[
T_y = YV
\]</span></p>
<p>After finding the first pair, we use a deflation process to remove their effect and proceed to find the next pair. This iterative process continues until we extract the desired number of canonical variable pairs.</p>
<p><span class="math display">\[
X = X-T_x(X^TT_U(T^T_UT_U)^{-1})^T
\]</span> and for <span class="math inline">\(Y\)</span></p>
<p><span class="math display">\[
Y = Y-T_y(Y^TT_U(T^T_UT_U)^{-1})^T
\]</span> The process is repeated to extract additional pairs of canonical variables.</p>
<p>Let’s have a look at how we can derive this in R using miRNA and mRNA data</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-8_08e6997bb67ae87d763035281755f3e9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center both of the datasets</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate cross-covariance matrix</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>cross_cov <span class="ot">&lt;-</span> <span class="fu">t</span>(X_centered)<span class="sc">%*%</span>Y_centered</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co"># do a svd (single eigenvector) this is going to give us a signle CCA component</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>svd_result <span class="ot">&lt;-</span> <span class="fu">svd</span>(cross_cov,<span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co"># extract the vectors</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>U <span class="ot">&lt;-</span> svd_result<span class="sc">$</span>u</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>V <span class="ot">&lt;-</span> svd_result<span class="sc">$</span>v</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the first canonical vectors (the most correlated latent factors)</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>canonical_vars_X <span class="ot">&lt;-</span> X_centered <span class="sc">%*%</span> U</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>canonical_vars_Y <span class="ot">&lt;-</span> Y_centered <span class="sc">%*%</span> V</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co"># deflate the original matrices</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> X_centered <span class="sc">-</span> canonical_vars_X <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(X_centered)<span class="sc">%*%</span>(canonical_vars_X)<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(canonical_vars_X)<span class="sc">%*%</span>(canonical_vars_X))))</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> Y_centered <span class="sc">-</span> canonical_vars_Y <span class="sc">%*%</span> </span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">t</span>(<span class="fu">t</span>(Y_centered)<span class="sc">%*%</span>(canonical_vars_Y)<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(canonical_vars_Y)<span class="sc">%*%</span>(canonical_vars_Y)))</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co"># redo the svd for the second component</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>cross_cov <span class="ot">&lt;-</span> <span class="fu">t</span>(X_centered)<span class="sc">%*%</span>Y_centered</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>svd_result <span class="ot">&lt;-</span> <span class="fu">svd</span>(cross_cov,<span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>U <span class="ot">&lt;-</span> svd_result<span class="sc">$</span>u</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>V <span class="ot">&lt;-</span> svd_result<span class="sc">$</span>v</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the second canonical vectors (the second most correlated latent factors)</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>canonical_vars_X2 <span class="ot">&lt;-</span> X_centered <span class="sc">%*%</span> U</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>canonical_vars_Y2 <span class="ot">&lt;-</span> Y_centered <span class="sc">%*%</span> V</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(canonical_vars_X,canonical_vars_X2,<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA miRNA"</span>)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(canonical_vars_Y,canonical_vars_Y2,<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA mRNA"</span>)</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(canonical_vars_X,canonical_vars_Y,<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"miRNA"</span>,<span class="at">ylab=</span><span class="st">"mRNA"</span>,<span class="at">main=</span><span class="st">"l1"</span>)</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(canonical_vars_X2,canonical_vars_Y2,<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"miRNA"</span>,<span class="at">ylab=</span><span class="st">"mRNA"</span>,<span class="at">main=</span><span class="st">"l2"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The plot above clearly shows that we ended up having a shared pattern in <code>l1</code> (first CCA component). L1 captures the primary mode of correlation between miRNA and mRNA expression data. It represents the linear combinations of miRNAs and mRNAs that are most strongly correlated. Since our interest right now is in the suptypes, we can probably ignore the second latent factor but we might as well try to explaining based on some other factors.</p>
<p>We are going to explore the loadings later when we explain multiomics CCA (GCCA) but for now remember that in the context of CCA, loadings play a role similar to that in PCA, yet they have a distinct interpretation. Similar to PCA, where loadings indicate the contribution of each original variable to the principal components, in CCA, the loadings show the contribution of each variable to the canonical variables. However, the difference lies in their meaning. While PCA loadings represent the contribution to the variance within a single dataset, CCA loadings show the contribution to the correlation between two datasets.</p>
<p>So far we have been going through CCA using two datasets. How can it be expaned to more than?</p>
</section>
<section id="generilized-canonical-correlation-analysis" class="level2">
<h2 class="anchored" data-anchor-id="generilized-canonical-correlation-analysis">Generilized Canonical Correlation Analysis</h2>
<p>Generilized Canonical Correlation Analysis (GCCA) is an extention of CCA to multiple datasets. We are going to introduce a few more concepts before diving into the GCCA.</p>
<p>We talked about SVD for PCA and CCA. While SVD provides a direct and efficient means to compute canonical correlations and vectors, there are alternative numerical approaches, such as the power method, which can be particularly useful for iterative computations, giving us a lot of flexibility in terms of applying modifications to the method.</p>
<section id="power-method" class="level3">
<h3 class="anchored" data-anchor-id="power-method">Power Method</h3>
<p>The power method is a classic numerical algorithm used to approximate the eigenvalue and the corresponding eigenvector of a matrix. It is used for large, sparse matrices.</p>
<section id="initial-steps" class="level4">
<h4 class="anchored" data-anchor-id="initial-steps">Initial Steps:</h4>
<ol type="1">
<li><p><em>Initialization:</em> Start with a random vector <span class="math inline">\(b_0\)</span>, which doesn’t have to be the eigenvector. Normalize this vector.</p></li>
<li><p><em>Iteration:</em> Multiply <span class="math inline">\(b_0\)</span> by the matrix <span class="math inline">\(A\)</span>, where <span class="math inline">\(A\)</span> is the matrix whose dominant eigenvalue and eigenvector we want to find.</p></li>
</ol>
</section>
<section id="iterative-formula" class="level4">
<h4 class="anchored" data-anchor-id="iterative-formula">Iterative Formula:</h4>
<p>The iterative formula for the power method is given by</p>
<p><span class="math display">\[
b_{k+1} = \frac{Ab_k}{\|Ab_k\|}
\]</span></p>
<p>where - <span class="math inline">\(A\)</span> is the matrix under consideration, - <span class="math inline">\(b_k\)</span> is the approximation of the dominant eigenvector at the <span class="math inline">\(k\)</span>th step, - <span class="math inline">\(\|Ab_k\|\)</span> is the norm of the vector <span class="math inline">\(Ab_k\)</span>, ensuring that <span class="math inline">\(b_{k+1}\)</span> is normalized.</p>
</section>
<section id="convergence" class="level4">
<h4 class="anchored" data-anchor-id="convergence">Convergence:</h4>
<p>The method converges when</p>
<p><span class="math display">\[
\|b_{k+1} - b_k\| &lt; \epsilon
\]</span></p>
<p>where <span class="math inline">\(\epsilon\)</span> is a small, pre-defined threshold indicating the level of accuracy desired.</p>
</section>
</section>
<section id="application-to-cca" class="level3">
<h3 class="anchored" data-anchor-id="application-to-cca">Application to CCA:</h3>
<p>In the context of CCA, the power method can be used to find the canonical correlations and vectors based on random vector or even better, the PC scores coming from SVD.</p>
<section id="steps-in-cca-context" class="level4">
<h4 class="anchored" data-anchor-id="steps-in-cca-context">Steps in CCA Context:</h4>
<ol type="1">
<li><strong>Calculate Initial Loadings:</strong>
<ul>
<li>Compute the initial loadings <span class="math inline">\(u_0\)</span> and <span class="math inline">\(v_0\)</span> for datasets <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> respectively, this can be done randomly!</li>
<li>Compute the initial scores <span class="math inline">\(s_{X,0} = Xu_0\)</span> and <span class="math inline">\(s_{Y,0} = Yv_0\)</span>.</li>
</ul></li>
<li><strong>Iteratively Update Loadings and Scores:</strong>
<ul>
<li>For each dataset, update the loadings based on the regression on the scores of the other dataset: <span class="math display">\[
u_{k+1} = X^T s_{Y,k}, \quad v_{k+1} = Y^T s_{X,k}.
\]</span></li>
<li>Normalize the updated loadings: <span class="math display">\[
u_{k+1} = \frac{u_{k+1}}{\|u_{k+1}\|}, \quad v_{k+1} = \frac{v_{k+1}}{\|v_{k+1}\|}.
\]</span></li>
<li>Update the scores: <span class="math display">\[
s_{X,k+1} = Xu_{k+1}, \quad s_{Y,k+1} = Yv_{k+1}.
\]</span></li>
</ul></li>
<li><strong>Check for Convergence:</strong>
<ul>
<li>Compute the change in loadings: <span class="math display">\[
\epsilon_u = \|u_{k+1} - u_k\|, \quad \epsilon_v = \|v_{k+1} - v_k\|.
\]</span></li>
<li>If <span class="math inline">\(max(\epsilon_u,\epsilon_v) &lt; \epsilon\)</span>, where <span class="math inline">\(\epsilon\)</span> is a small positive threshold, the algorithm has converged.</li>
</ul></li>
<li><strong>Deflation:</strong>
<ul>
<li>After obtaining each pair of canonical variables, deflate the datasets to extract additional canonical variables: <span class="math display">\[
X = X - s_{X,k+1} \left( \frac{X^T s_{X,k+1}}{s_{X,k+1}^T s_{X,k+1}} \right)^T,
\]</span> <span class="math display">\[
Y = Y - s_{Y,k+1} \left( \frac{Y^T s_{Y,k+1}}{s_{Y,k+1}^T s_{Y,k+1}} \right)^T.
\]</span></li>
</ul></li>
</ol>
<p>The loadings are updated by projecting each dataset onto the scores of the other dataset, capturing the shared information and maximizing the correlation between the datasets. The convergence criterion ensures that the iterative process stops when the loadings become stable, indicating that the canonical variables that maximize the correlation between the datasets have been found. The deflation step is similar to that of SVD.</p>
</section>
<section id="implemntation-in-r" class="level4">
<h4 class="anchored" data-anchor-id="implemntation-in-r">Implemntation in R</h4>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-9_96ee74e51a7bacd34aabe69bc5da794b">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">mrna=</span>Y_centered)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># define the number of components</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>number_of_components <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>scores_list<span class="ot">&lt;-</span><span class="fu">list</span>()</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(cmp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_of_components)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the loadings based on random data</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">&lt;-</span> <span class="fu">lapply</span>(data_merged,<span class="cf">function</span>(x){<span class="fu">runif</span>(<span class="fu">ncol</span>(x))})</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co"># define an empty loading for new ones</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>new_loadings<span class="ot">&lt;-</span>initial_loadings</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>new_loadings[]<span class="ot">&lt;-</span><span class="cn">NA</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the PC scores</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>pc_scores <span class="ot">&lt;-</span> <span class="fu">mapply</span>(<span class="cf">function</span>(x,y){x<span class="sc">%*%</span>y},<span class="at">x=</span>data_merged,<span class="at">y=</span>initial_loadings)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span>{</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="co"># dataset index</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>data_index<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="co"># for each dataset</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged))</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># reestimate the loadings based on the regreesion on the scores of the other dataset</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(data_merged[[i]], </span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>                  pc_scores[,data_index<span class="sc">!=</span>i])</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># normalize the loadings </span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">=</span> new_loadings[[i]]<span class="sc">/</span><span class="fu">drop</span>(<span class="fu">sqrt</span>(<span class="fu">crossprod</span>(new_loadings[[i]])))</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># update the scores</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>  pc_scores[, i] <span class="ot">=</span> data_merged[[i]] <span class="sc">%*%</span> new_loadings[[i]]</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>scores_list[[cmp]]<span class="ot">&lt;-</span>pc_scores</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate epsilone</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>epi <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged), <span class="cf">function</span>(x) {</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>            <span class="fu">crossprod</span>(new_loadings[[x]] <span class="sc">-</span> initial_loadings[[x]])</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>        }))</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(epi<span class="sc">&lt;</span>.Machine<span class="sc">$</span>double.eps)</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">break</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a><span class="co"># update the old loadings</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">=</span> new_loadings</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a><span class="co"># perform deflation</span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged),<span class="cf">function</span>(x){</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="ot">&lt;-</span> data_merged[[x]]</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="sc">-</span> pc_scores[,x,drop<span class="ot">=</span>F] <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(x_tmp)<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F]))))</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">1</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">1</span>],</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA miRNA"</span>)</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">2</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">2</span>],</span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA miRNA"</span>)</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">1</span>],scores_list[[<span class="dv">1</span>]][,<span class="dv">2</span>],<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"miRNA"</span>,<span class="at">ylab=</span><span class="st">"mRNA"</span>,<span class="at">main=</span><span class="st">"l1"</span>)</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">2</span>]][,<span class="dv">1</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">2</span>],<span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"miRNA"</span>,<span class="at">ylab=</span><span class="st">"mRNA"</span>,<span class="at">main=</span><span class="st">"l2"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Now than we see that we can optain similar results (remember the direction of axis is not important), we can try to expand the power method for multiple omics</p>
</section>
<section id="power-method-for-multiple-datasets" class="level4">
<h4 class="anchored" data-anchor-id="power-method-for-multiple-datasets">Power method for multiple datasets</h4>
<p>In the previous algorithm we had only two datasets. In the updating step we perform a simple regression of dataset <span class="math inline">\(X\)</span> and the scores of dataset <span class="math inline">\(Y\)</span> and vice versa.</p>
<p><span class="math display">\[
     u_{k+1} = X^T s_{Y,k}, \quad v_{k+1} = Y^T s_{X,k}.
\]</span> A simple solution to address the integration using multiple datasets is to estimate the loading based the regression on the joint scores. This means that given dataset <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span> and <span class="math inline">\(Z\)</span>, for calculate for scores, we are going to take one of the datasets and regress it agains the weighted sum of scores from the two other dataset. So we are going to do:</p>
<p><span class="math display">\[
s_X = X^T (w_Y \cdot s_Y + w_Z \cdot s_Z),
\]</span></p>
<p>where <span class="math inline">\(w_Y\)</span> and <span class="math inline">\(w_Z\)</span> are the weights assigned to the scores of <span class="math inline">\(Y\)</span> and <span class="math inline">\(Z\)</span> respectively.</p>
<p>Similarly, for dataset <span class="math inline">\(Y\)</span>: <span class="math display">\[
    s_Y = Y^T (w_X \cdot s_X + w_Z \cdot s_Z),
    \]</span> and for dataset <span class="math inline">\(Z\)</span>: <span class="math display">\[
    s_Z = Z^T (w_X \cdot s_X + w_Y \cdot s_Y).
    \]</span></p>
<p>So given this simple update we can now perform CCA on multiple datasets.</p>
<p>Let’s try to implement this in R just using weight of 1. To make things faster, instead of random assignment of loadings, we start with SVD.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-10_d3da42e4fde13d41966ddd5d3806d055">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Z_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>protein, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">mrna=</span>Y_centered,<span class="at">protein=</span>Z_centered)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># define the number of components</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>number_of_components <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>scores_list<span class="ot">&lt;-</span><span class="fu">list</span>()</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(cmp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_of_components)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the loadings based on SVD</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">&lt;-</span> <span class="fu">lapply</span>(data_merged,<span class="cf">function</span>(x){<span class="fu">svd</span>(x,<span class="dv">1</span>,<span class="dv">1</span>)<span class="sc">$</span>v})</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="co"># define an empty loading for new ones</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>new_loadings<span class="ot">&lt;-</span>initial_loadings</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>new_loadings[]<span class="ot">&lt;-</span><span class="cn">NA</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the PC scores</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>pc_scores <span class="ot">&lt;-</span> <span class="fu">mapply</span>(<span class="cf">function</span>(x,y){x<span class="sc">%*%</span>y},<span class="at">x=</span>data_merged,<span class="at">y=</span>initial_loadings)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span>{</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co"># dataset index</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>data_index<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="co"># for each dataset</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged))</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># reestimate the loadings based on the regreesion on the scores of the other dataset</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(data_merged[[i]], </span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">rowSums</span>(pc_scores[,data_index<span class="sc">!=</span>i])) <span class="do">## row sum will calculate the sum of all the scores for each datapoint across different datasets</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># normalize the loadings </span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">=</span> new_loadings[[i]]<span class="sc">/</span><span class="fu">drop</span>(<span class="fu">sqrt</span>(<span class="fu">crossprod</span>(new_loadings[[i]])))</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># update the scores</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>  pc_scores[, i] <span class="ot">=</span> data_merged[[i]] <span class="sc">%*%</span> new_loadings[[i]]</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>scores_list[[cmp]]<span class="ot">&lt;-</span>pc_scores</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate epsilone</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>epi <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged), <span class="cf">function</span>(x) {</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>            <span class="fu">crossprod</span>(new_loadings[[x]] <span class="sc">-</span> initial_loadings[[x]])</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>        }))</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(epi<span class="sc">&lt;</span>.Machine<span class="sc">$</span>double.eps)</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">break</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="co"># update the old loadings</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">=</span> new_loadings</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span class="co"># perform deflation</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged),<span class="cf">function</span>(x){</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="ot">&lt;-</span> data_merged[[x]]</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="sc">-</span> pc_scores[,x,drop<span class="ot">=</span>F] <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(x_tmp)<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F]))))</span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">1</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">1</span>],</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA miRNA"</span>)</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">2</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">2</span>],</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA miRNA"</span>)</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">3</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">3</span>],</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"CCA protein"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Congratulation. We now have fully functional CCA for data integration. We can do clustering, regression etc on the latent variables or go ahead and interpret the loadings.</p>
</section>
</section>
<section id="gcca-in-r" class="level3">
<h3 class="anchored" data-anchor-id="gcca-in-r">GCCA in R</h3>
<p>In reality one does not have to implement the whole algorithm! mixOmics provides us with a very good interface to do GCCA with a lot of flexibility. The main function is <code>wrapper.sgcca</code> and we are going to have a look some its main functionality now.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-11_8ddcfa6d1fdfef5bb08989dca14432c4">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># prepare data</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>Z_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>protein, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">mrna=</span>Y_centered,<span class="at">protein=</span>Z_centered)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co"># perform a simple GCCA</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>gcc_three_datasets <span class="ot">&lt;-</span> mixOmics<span class="sc">::</span><span class="fu">wrapper.sgcca</span>(data_merged,<span class="at">ncomp =</span> <span class="dv">2</span>,<span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>mixOmics<span class="sc">::</span><span class="fu">plotIndiv</span>(gcc_three_datasets,<span class="at">group =</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">ind.names =</span> <span class="cn">FALSE</span>,<span class="at">legend =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>So here comes the similar score plot of GCCA. We can clearly see the shared latent factors discovered by GCCA, separating our three groups. We can invesitage loadings to know more about what variables has more influence on these latent components.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-12_156823a9ce1cbee3660b76b248d6a1f4">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>mixOmics<span class="sc">::</span><span class="fu">plotLoadings</span>(gcc_three_datasets,<span class="at">comp =</span> <span class="dv">1</span>,<span class="at">ndisplay =</span> <span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here instead of having a single loading plot (i choice to show 20 variables for the sake of better plotting), we have three (one for each omics). Here the interpretation is the same as PCA loadings. The higher the absolute value the more influence a particular variable has on the latent scores.</p>
<p>There are options provided by the function. We are going to focus on the most imporant ones, namely <code>design</code> and <code>keepX</code>.</p>
<p>As we previously demonstrated, we can weight the scores from different omics before combining them. The <code>design</code> parameter gives us a powerful way of choosing which data view to focus on more and define the relation between the data.</p>
<p>Think of <code>design</code> as a grid where each cell’s value, ranging from 0 to 1, indicates the strength of the relationship between two corresponding data blocks. A value of 0 means no relationship, while 1 signifies a strong connection. When you’re setting up your analysis, adjusting these values can help you emphasize or de-emphasize certain relationships, giving you the flexibility to focus on specific interactions that are of interest.</p>
<p>For instance, if you’re curious about how two particular blocks of data interact, you’d set their corresponding value in the design matrix closer to 1. This tells sGCCA, “Hey, pay extra attention here!” Conversely, if you believe two other blocks aren’t significantly related, setting their value closer to 0 directs the analysis to not invest much energy in exploring that connection.</p>
<p>in our previous example, we chose not to provide a design matrix, in this case, mixOmics will construct a design matrix in all datasets have strongest connect (1) to each other.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-13_d0d15a681d9b50d1f9b24c014a2df46e">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(gcc_three_datasets<span class="sc">$</span>design)<span class="ot">&lt;-</span><span class="fu">colnames</span>(gcc_three_datasets<span class="sc">$</span>design)<span class="ot">&lt;-</span><span class="fu">names</span>(data_merged)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(gcc_three_datasets<span class="sc">$</span>design)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        mirna mrna protein
mirna       0    1       1
mrna        1    0       1
protein     1    1       0</code></pre>
</div>
</div>
<p><strong>Can you construct a design matrix and and rerun <code>wrapper.sgcca</code> and plot the results?</strong></p>
<p>Lastly, <code>keepX</code>! This parameter is used in refining your GCCA analysis. It lets you to specify the number of variables to retain in each block of data during the analysis. <code>keepX</code> is like a filter that helps you keep only the most valuable variables, enhancing the clarity and focus of your analysis. You provide a vector of integers to keepX, each integer corresponding to the number of variables you want to retain from each data block. It’s a balancing act - retaining more variables can capture complex patterns but might also introduce noise. On the other hand, keeping fewer variables simplifies the model but might miss out on nuanced interactions. Adjusting keepX is a practical step in iterative model refinement, ensuring that your analysis is both robust and focused, honing in on the most informative variables to answer your specific research questions.</p>
<p><strong>Can you set wrapper.sgcca to retain only 10 variables for each omics? Plot the data and the loadings</strong></p>
<p>For us, it is time to switch to supervised data integration using mixOmics.</p>
</section>
</section>
</section>
<section id="supervised-integration" class="level1">
<h1>Supervised integration</h1>
<p>So far we have been dealing with unsupervised data integration. Although we mentioned that we have done regression we did not do that for the purpose of predicting an outcome but rather just to connect different block of the data together through a shared subspace (latent factors).</p>
<section id="partial-least-squares" class="level2">
<h2 class="anchored" data-anchor-id="partial-least-squares">Partial Least Squares</h2>
<p>We are now going to formally define an outcome variable and use that to perform supervised data integration. This is where Partial Least Squares (PLS) comes into play, a method that not only facilitates the integration of data from various sources but also enables the prediction of an outcome variable by identifying the relationships between observed variables and the outcomes of interest.</p>
<p>Partial Least Squares (PLS) is a statistical method used in the context of predictive modeling and data analysis. It serves as a bridge between principal component analysis (PCA) and regression analysis. PLS is particularly useful when dealing with complex, high-dimensional, and multicollinear data, where traditional regression models may falter due to overfitting or multicollinearity issues.</p>
<p>In PLS, the predictor variables (or features) and the response variables (or outcomes) are projected to a new subspace formed by latent variables (or components). These latent variables are linear combinations of the original variables and are constructed in such a way that they maximize the covariance between the predictors and the response. This is a key distinction from PCA, which only considers the variance of the predictors.</p>
<p>The PLS model aims to find the optimal set of weights that, when applied to the original variables, gives the best possible prediction of the outcome variable. It does this by decomposing both the predictor matrix <span class="math inline">\(X\)</span> and the response matrix <span class="math inline">\(Y\)</span> into the product of two lower-dimensional matrices, capturing the most relevant information in the data for predicting outcomes.</p>
<p>Mathematically, the decomposition can be represented as: <span class="math display">\[
X = T P^T + E
\]</span> <span class="math display">\[
Y = U Q^T + F
\]</span></p>
<p>where: - <span class="math inline">\(X\)</span> is the matrix of predictor variables, - <span class="math inline">\(Y\)</span> is the matrix of response variables, - <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> are matrices of scores representing the latent variables, - <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are matrices of loadings, - <span class="math inline">\(E\)</span> and <span class="math inline">\(F\)</span> are matrices of residuals.</p>
<p>More specifically, there are two main differences between CCA and PLS when it comes to underlining equations. In CCA, we first calculate each covariance matrix for each dataset and then continue with the deflation. In contrast, in PLS, we need to calculate the cross covariance between between X and Y followed by SVD and deflation.</p>
<p>The second difference is the deflation procedure itself. The main difference lies in the scores used for deflation. In CCA, each block is deflated by its own scores, while in PLS, both blocks are deflated by the <span class="math inline">\(X\)</span> scores, ensuring that the shared information captured is based on the covariance between <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</p>
<p>In CCA,:</p>
<p><span class="math display">\[
X' = X - T_X (X^T T_X) (T_X^T T_X)^{-1}
\]</span> <span class="math display">\[
Y' = Y - T_Y (Y^T T_Y) (T_Y^T T_Y)^{-1}
\]</span></p>
<p>Where: - <span class="math inline">\(T_Y\)</span> is the matrix of scores associated with <span class="math inline">\(Y\)</span>.</p>
<p>PLS Deflation:</p>
<p>For the <span class="math inline">\(X\)</span> block:</p>
<p><span class="math display">\[
X' = X - T_X (X^T T_X) (T_X^T T_X)^{-1}
\]</span></p>
<p>For the <span class="math inline">\(Y\)</span> block:</p>
<p><span class="math display">\[
Y' = Y - T_X (Y^T T_X) (T_X^T T_X)^{-1}
\]</span></p>
<p>In these equations: - <span class="math inline">\(X'\)</span> and <span class="math inline">\(Y'\)</span> are the deflated <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> blocks, respectively. - <span class="math inline">\(T_X\)</span> is the matrix of scores associated with <span class="math inline">\(X\)</span>. - The operation <span class="math inline">\(X^T T_X\)</span> and <span class="math inline">\(Y^T T_X\)</span> calculates the projection of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> on the scores <span class="math inline">\(T_X\)</span>. - The term <span class="math inline">\((T_X^T T_X)^{-1}\)</span> is the inverse of the matrix resulting from the multiplication of <span class="math inline">\(T_X^T\)</span> and <span class="math inline">\(T_X\)</span>, used for normalization.</p>
<p>So to see this in practice we will change our R code and do PLS instead of CCA. In the following example, we are going to using our mirna data as X and protein as Y. It is important to note that one of the most amazing properties of PLS is the capability to regress on multivariate outcome in contrast to ordinary regression which often involes a single outcome.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-14_34f706126245aaf1a4ff0d4ad18cf8a1">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>Z_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>protein, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co"># define y index</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>y_index <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">y=</span>Z_centered)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co"># define the number of components</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>number_of_components <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>scores_list<span class="ot">&lt;-</span><span class="fu">list</span>()</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(cmp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_of_components)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the loadings based on SVD how cross covariance matrix</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">&lt;-</span> <span class="fu">lapply</span>(data_merged,<span class="cf">function</span>(x){<span class="fu">svd</span>(<span class="fu">t</span>(x)<span class="sc">%*%</span>data_merged[[y_index]],<span class="dv">1</span>,<span class="dv">1</span>)<span class="sc">$</span>u})</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>initial_loadings[[<span class="fu">length</span>(initial_loadings)]] <span class="ot">&lt;-</span> <span class="fu">lapply</span>(data_merged,<span class="cf">function</span>(x){<span class="fu">svd</span>(<span class="fu">t</span>(x)<span class="sc">%*%</span>data_merged[[<span class="dv">2</span>]],<span class="dv">1</span>,<span class="dv">1</span>)<span class="sc">$</span>v})[[<span class="dv">1</span>]]</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="co"># define an empty loading for new ones</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>new_loadings<span class="ot">&lt;-</span>initial_loadings</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>new_loadings[]<span class="ot">&lt;-</span><span class="cn">NA</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the PC scores</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>pc_scores <span class="ot">&lt;-</span> <span class="fu">mapply</span>(<span class="cf">function</span>(x,y){x<span class="sc">%*%</span>y},<span class="at">x=</span>data_merged,<span class="at">y=</span>initial_loadings)</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span>{</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a><span class="co"># dataset index</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>data_index<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a><span class="co"># for each dataset</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged))</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># reestimate the loadings based on the regreesion on the scores of the other dataset</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(data_merged[[i]], </span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">rowSums</span>(pc_scores[,data_index<span class="sc">!=</span>i,<span class="at">drop=</span>F])) <span class="do">## row sum will calculate the sum of all the scores for each datapoint across different datasets</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>  <span class="co"># normalize the loadings </span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">=</span> new_loadings[[i]]<span class="sc">/</span><span class="fu">drop</span>(<span class="fu">sqrt</span>(<span class="fu">crossprod</span>(new_loadings[[i]])))</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>  <span class="co"># update the scores</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>  pc_scores[, i] <span class="ot">=</span> data_merged[[i]] <span class="sc">%*%</span> new_loadings[[i]]</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>scores_list[[cmp]]<span class="ot">&lt;-</span>pc_scores</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate epsilone</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>epi <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged), <span class="cf">function</span>(x) {</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>            <span class="fu">crossprod</span>(new_loadings[[x]] <span class="sc">-</span> initial_loadings[[x]])</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>        }))</span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(epi<span class="sc">&lt;</span>.Machine<span class="sc">$</span>double.eps)</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>  <span class="cf">break</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a><span class="co"># update the old loadings</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">=</span> new_loadings</span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a><span class="co"># perform deflation on X first</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>data_merged[<span class="sc">-</span>y_index]<span class="ot">&lt;-</span><span class="fu">lapply</span>((<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged))[<span class="sc">-</span>y_index],<span class="cf">function</span>(x){</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="ot">&lt;-</span> data_merged[[x]]</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="sc">-</span> pc_scores[,x,drop<span class="ot">=</span>F] <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(x_tmp)<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F]))))</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a><span class="co"># perform deflation</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>data_merged[y_index]<span class="ot">&lt;-</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lapply</span>(y_index,<span class="cf">function</span>(x){</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="ot">&lt;-</span> data_merged[[x]]</span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="sc">-</span> pc_scores[,<span class="sc">-</span>x,drop<span class="ot">=</span>F] <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(x_tmp)<span class="sc">%*%</span>(pc_scores[,<span class="sc">-</span>x,<span class="at">drop=</span>F])<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(pc_scores[,<span class="sc">-</span>x,<span class="at">drop=</span>F])<span class="sc">%*%</span>(pc_scores[,<span class="sc">-</span>x,<span class="at">drop=</span>F]))))</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">1</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">1</span>],</span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"PLS miRNA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Here we ended up with the single pairs of scores which maximize the covariance between the miRNA and proteins. You can think about PLS as ordinary regression where both the predictor and response variables are simultaneously transformed to a new space defined by latent variables. These latent variables are constructed to maximize the covariance between the transformed predictor and response variables, ensuring that the most relevant features for prediction are captured. Unlike ordinary regression, which can struggle with multicollinearity and high-dimensional data, PLS handles these issues efficiently by reducing the dimensionality and focusing on the most informative components of the data.</p>
</section>
<section id="partial-least-squares-1" class="level2">
<h2 class="anchored" data-anchor-id="partial-least-squares-1">Partial Least Squares</h2>
<p>As you have noticed, PLS alogrithm is not an integrative method. It is still applied on a single block of data (if we ignore Y as a block). Extension of PLS to multiple blocks of data is streight forward. We keep what we have done for CCA. The only part that we have to change is the deflation of <span class="math inline">\(Y\)</span>. As we said given the block <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> the deflation of <span class="math inline">\(Y\)</span> is based on the information captured in <span class="math inline">\(X\)</span>, meaning its scores <span class="math inline">\(T\)</span>. When it comes to multiple omics (data views), we don’t have a single matrix of <span class="math inline">\(X\)</span> but rather we have <span class="math inline">\(X_k\)</span> where <span class="math inline">\(k\)</span> can be <span class="math inline">\(1...K\)</span>, each is a separate dataset. A simple way to do the deflation of <span class="math inline">\(Y\)</span> relative to all the <span class="math inline">\(X_k\)</span> is to deflate the <span class="math inline">\(Y\)</span> for each dataset separately and then take the average of all deflation. More concretely,</p>
<p><span class="math display">\[
\Delta Y_k = Y - T_{x_k} \cdot \left( Y^T \cdot T_{x_k} \cdot (T_{x_k}^T \cdot T_{x_k})^{-1} \right)^T
\]</span></p>
<p>where - <span class="math inline">\(Y\)</span> is the response matrix, - <span class="math inline">\(T_{x_k}\)</span> is the score matrix corresponding to the <span class="math inline">\(k\)</span>-th block of predictors, - <span class="math inline">\(\Delta Y_k\)</span> is the deflated <span class="math inline">\(Y\)</span> corresponding to the <span class="math inline">\(k\)</span>-th block of predictors.</p>
<p>Then, the final deflated <span class="math inline">\(Y\)</span> is obtained by averaging all the individual deflations:</p>
<p><span class="math display">\[
\Delta Y_{\text{final}} = \frac{1}{K} \sum_{k=1}^K \Delta Y_k
\]</span></p>
<p>This ensures that the deflation of <span class="math inline">\(Y\)</span> takes into account the information captured in all blocks of predictors, leading to a more comprehensive and integrative analysis when dealing with multiple omics or data views.</p>
<p>We can do a simple change to our previous code to do that.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-15_092b033595f972755bfee4da0ca2c373">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>Z_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>protein, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># define y index</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>y_index <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">mrna=</span>Y_centered,<span class="at">y=</span>Z_centered)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co"># define the number of components</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>number_of_components <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>scores_list<span class="ot">&lt;-</span><span class="fu">list</span>()</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(cmp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_of_components)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize the loadings based on SVD how cross covariance matrix</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">&lt;-</span> <span class="fu">lapply</span>(data_merged,<span class="cf">function</span>(x){<span class="fu">svd</span>(<span class="fu">t</span>(x)<span class="sc">%*%</span>data_merged[[y_index]],<span class="dv">1</span>,<span class="dv">1</span>)<span class="sc">$</span>u})</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>initial_loadings[[y_index]] <span class="ot">&lt;-</span> <span class="fu">lapply</span>(data_merged,<span class="cf">function</span>(x){<span class="fu">svd</span>(<span class="fu">t</span>(x)<span class="sc">%*%</span>data_merged[[y_index]],<span class="dv">1</span>,<span class="dv">1</span>)<span class="sc">$</span>v})[[<span class="dv">1</span>]]</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co"># define an empty loading for new ones</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>new_loadings<span class="ot">&lt;-</span>initial_loadings</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>new_loadings[]<span class="ot">&lt;-</span><span class="cn">NA</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the PC scores</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>pc_scores <span class="ot">&lt;-</span> <span class="fu">mapply</span>(<span class="cf">function</span>(x,y){x<span class="sc">%*%</span>y},<span class="at">x=</span>data_merged,<span class="at">y=</span>initial_loadings)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="cf">repeat</span>{</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="co"># dataset index</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>data_index<span class="ot">&lt;-</span><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged)</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="co"># for each dataset</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged))</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># reestimate the loadings based on the regreesion on the scores of the other dataset</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(data_merged[[i]], </span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">rowSums</span>(pc_scores[,data_index<span class="sc">!=</span>i,<span class="at">drop=</span>F])) <span class="do">## row sum will calculate the sum of all the scores for each datapoint across different datasets</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># normalize the loadings </span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>  new_loadings[[i]] <span class="ot">=</span> new_loadings[[i]]<span class="sc">/</span><span class="fu">drop</span>(<span class="fu">sqrt</span>(<span class="fu">crossprod</span>(new_loadings[[i]])))</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>  <span class="co"># update the scores</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>  pc_scores[, i] <span class="ot">=</span> data_merged[[i]] <span class="sc">%*%</span> new_loadings[[i]]</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>scores_list[[cmp]]<span class="ot">&lt;-</span>pc_scores</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate epsilone</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>epi <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged), <span class="cf">function</span>(x) {</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>            <span class="fu">crossprod</span>(new_loadings[[x]] <span class="sc">-</span> initial_loadings[[x]])</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>        }))</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(epi<span class="sc">&lt;</span>.Machine<span class="sc">$</span>double.eps)</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">break</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a><span class="co"># update the old loadings</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>initial_loadings <span class="ot">=</span> new_loadings</span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a><span class="co"># perform deflation on X first</span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>data_merged[<span class="sc">-</span>y_index]<span class="ot">&lt;-</span><span class="fu">lapply</span>((<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged))[<span class="sc">-</span>y_index],<span class="cf">function</span>(x){</span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="ot">&lt;-</span> data_merged[[x]]</span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="sc">-</span> pc_scores[,x,drop<span class="ot">=</span>F] <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(x_tmp)<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F]))))</span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a><span class="co"># perform deflation of Y which has been changed now!</span></span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a>data_merged[[y_index]]<span class="ot">&lt;-</span><span class="fu">Reduce</span>(<span class="st">"+"</span>,</span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lapply</span>(<span class="fu">seq</span>(<span class="dv">1</span>,<span class="fu">length</span>(data_merged))[<span class="sc">-</span>y_index],<span class="cf">function</span>(x){</span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="ot">&lt;-</span> data_merged[[y_index]]</span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>  x_tmp <span class="sc">-</span> pc_scores[,x,drop<span class="ot">=</span>F] <span class="sc">%*%</span> <span class="fu">t</span>((<span class="fu">t</span>(x_tmp)<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(pc_scores[,x,<span class="at">drop=</span>F])<span class="sc">%*%</span>(pc_scores[,x,<span class="at">drop=</span>F]))))</span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb17-66"><a href="#cb17-66" aria-hidden="true" tabindex="-1"></a>  }))<span class="sc">/</span>(<span class="fu">length</span>(data_merged)<span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb17-67"><a href="#cb17-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-72"><a href="#cb17-72" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb17-73"><a href="#cb17-73" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">1</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">1</span>],</span>
<span id="cb17-74"><a href="#cb17-74" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"PLS miRNA"</span>)</span>
<span id="cb17-75"><a href="#cb17-75" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(scores_list[[<span class="dv">1</span>]][,<span class="dv">2</span>],scores_list[[<span class="dv">2</span>]][,<span class="dv">2</span>],</span>
<span id="cb17-76"><a href="#cb17-76" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">xlab=</span><span class="st">"l1"</span>,<span class="at">ylab=</span><span class="st">"l2"</span>,<span class="at">main=</span><span class="st">"PLS mRNA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Using mixOmics one can easily perform multiblock PLS using <code>block.pls</code> function.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-16_85c3a09ca9e2461bccc549d96b148985">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>Z_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>protein, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"># define y index</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>y_index <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">mrna=</span>Y_centered,<span class="at">y=</span>Z_centered)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co"># perform pls</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>block_pls_results <span class="ot">&lt;-</span> mixOmics<span class="sc">::</span><span class="fu">block.pls</span>(data_merged,<span class="at">indY =</span> y_index,<span class="at">scale =</span> <span class="cn">FALSE</span>,<span class="at">ncomp =</span> <span class="dv">2</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the results</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>mixOmics<span class="sc">::</span><span class="fu">plotIndiv</span>(block_pls_results,<span class="at">group =</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">ind.names =</span> F,<span class="at">legend =</span> T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>As you have noted, we have fitted a supervised regression model that uses miRNA and mRNA data to predict protein expression. Regression models are used when we have a continous response variable. How about if instead of protein expression we wanted to predict cancer subtype using miRNA and mRNA data? Cancer subtype is categorical which does not follow the assumption of the PLS.</p>
<p>Fortunately there is a simple trick that can be used to perform classification using PLS which turns PLS into PLS-DA (partial least squares discriminant analysis).</p>
</section>
<section id="pls-da" class="level2">
<h2 class="anchored" data-anchor-id="pls-da">PLS-DA</h2>
<p>The simple trick to use PLS to do classification is to convert our categorical response to a numerical matrix. We can then do standard PLS using this matrix as Y. If you have a categorical outcome variable <span class="math inline">\(Y\)</span> with <span class="math inline">\(K\)</span> levels, you can convert it into a dummy matrix <span class="math inline">\(D\)</span> using the following mathematical representation. Let <span class="math inline">\(Y = \{y_1, y_2, \ldots, y_n\}\)</span> be a vector of <span class="math inline">\(n\)</span> observations of the categorical variable, where each <span class="math inline">\(y_i\)</span> can take on one of <span class="math inline">\(K\)</span> distinct values or levels. The dummy matrix <span class="math inline">\(D\)</span> is then an <span class="math inline">\(n \times K\)</span> matrix defined as</p>
<p><span class="math display">\[
D_{ij} =
\begin{cases}
1 &amp; \text{if } y_i = j \\
0 &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>for <span class="math inline">\(i = 1, 2, \ldots, n\)</span> and <span class="math inline">\(j = 1, 2, \ldots, K\)</span>.</p>
<p>Each column of <span class="math inline">\(D\)</span> corresponds to one level of the categorical variable <span class="math inline">\(Y\)</span>, and each row corresponds to an observation. The elements of <span class="math inline">\(D\)</span> are binary indicators, with a 1 indicating the presence of the corresponding level for that observation and 0 indicating the absence.</p>
<p>Here is a simple code to do that!</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-17_f836bbcbae35e080ecb1dffe269b83e0">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a factor variable</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the levels of the factor</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>levels <span class="ot">&lt;-</span> <span class="fu">unique</span>(Y)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dummy matrix</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>dummy_matrix <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="fu">length</span>(Y), <span class="at">ncol =</span> <span class="fu">length</span>(levels))</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(dummy_matrix) <span class="ot">&lt;-</span> levels</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Fill in the dummy matrix</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(levels)) {</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  dummy_matrix[, i] <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(Y <span class="sc">==</span> levels[i])</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the dummy matrix</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(dummy_matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       Basal Her2 LumA
  [1,]     1    0    0
  [2,]     1    0    0
  [3,]     1    0    0
  [4,]     1    0    0
  [5,]     1    0    0
  [6,]     1    0    0
  [7,]     1    0    0
  [8,]     1    0    0
  [9,]     1    0    0
 [10,]     1    0    0
 [11,]     1    0    0
 [12,]     1    0    0
 [13,]     1    0    0
 [14,]     1    0    0
 [15,]     1    0    0
 [16,]     1    0    0
 [17,]     1    0    0
 [18,]     1    0    0
 [19,]     1    0    0
 [20,]     1    0    0
 [21,]     1    0    0
 [22,]     1    0    0
 [23,]     1    0    0
 [24,]     1    0    0
 [25,]     1    0    0
 [26,]     1    0    0
 [27,]     1    0    0
 [28,]     1    0    0
 [29,]     1    0    0
 [30,]     1    0    0
 [31,]     1    0    0
 [32,]     1    0    0
 [33,]     1    0    0
 [34,]     1    0    0
 [35,]     1    0    0
 [36,]     1    0    0
 [37,]     1    0    0
 [38,]     1    0    0
 [39,]     1    0    0
 [40,]     1    0    0
 [41,]     1    0    0
 [42,]     1    0    0
 [43,]     1    0    0
 [44,]     1    0    0
 [45,]     1    0    0
 [46,]     0    1    0
 [47,]     0    1    0
 [48,]     0    1    0
 [49,]     0    1    0
 [50,]     0    1    0
 [51,]     0    1    0
 [52,]     0    1    0
 [53,]     0    1    0
 [54,]     0    1    0
 [55,]     0    1    0
 [56,]     0    1    0
 [57,]     0    1    0
 [58,]     0    1    0
 [59,]     0    1    0
 [60,]     0    1    0
 [61,]     0    1    0
 [62,]     0    1    0
 [63,]     0    1    0
 [64,]     0    1    0
 [65,]     0    1    0
 [66,]     0    1    0
 [67,]     0    1    0
 [68,]     0    1    0
 [69,]     0    1    0
 [70,]     0    1    0
 [71,]     0    1    0
 [72,]     0    1    0
 [73,]     0    1    0
 [74,]     0    1    0
 [75,]     0    1    0
 [76,]     0    0    1
 [77,]     0    0    1
 [78,]     0    0    1
 [79,]     0    0    1
 [80,]     0    0    1
 [81,]     0    0    1
 [82,]     0    0    1
 [83,]     0    0    1
 [84,]     0    0    1
 [85,]     0    0    1
 [86,]     0    0    1
 [87,]     0    0    1
 [88,]     0    0    1
 [89,]     0    0    1
 [90,]     0    0    1
 [91,]     0    0    1
 [92,]     0    0    1
 [93,]     0    0    1
 [94,]     0    0    1
 [95,]     0    0    1
 [96,]     0    0    1
 [97,]     0    0    1
 [98,]     0    0    1
 [99,]     0    0    1
[100,]     0    0    1
[101,]     0    0    1
[102,]     0    0    1
[103,]     0    0    1
[104,]     0    0    1
[105,]     0    0    1
[106,]     0    0    1
[107,]     0    0    1
[108,]     0    0    1
[109,]     0    0    1
[110,]     0    0    1
[111,]     0    0    1
[112,]     0    0    1
[113,]     0    0    1
[114,]     0    0    1
[115,]     0    0    1
[116,]     0    0    1
[117,]     0    0    1
[118,]     0    0    1
[119,]     0    0    1
[120,]     0    0    1
[121,]     0    0    1
[122,]     0    0    1
[123,]     0    0    1
[124,]     0    0    1
[125,]     0    0    1
[126,]     0    0    1
[127,]     0    0    1
[128,]     0    0    1
[129,]     0    0    1
[130,]     0    0    1
[131,]     0    0    1
[132,]     0    0    1
[133,]     0    0    1
[134,]     0    0    1
[135,]     0    0    1
[136,]     0    0    1
[137,]     0    0    1
[138,]     0    0    1
[139,]     0    0    1
[140,]     0    0    1
[141,]     0    0    1
[142,]     0    0    1
[143,]     0    0    1
[144,]     0    0    1
[145,]     0    0    1
[146,]     0    0    1
[147,]     0    0    1
[148,]     0    0    1
[149,]     0    0    1
[150,]     0    0    1</code></pre>
</div>
</div>
<p>That was pretty much it. We can do PLS on this matrix which is equal to doing PLS-DA.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-18_0b6d509ff499a42ff03f02ecf87818a5">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># center the data</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>X_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>Y_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna, <span class="at">scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>Z_centered <span class="ot">&lt;-</span> <span class="fu">scale</span>(dummy_matrix, <span class="at">scale =</span> <span class="cn">FALSE</span>) <span class="co"># note this has replaced protein expression</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(Z_centered)<span class="ot">&lt;-</span><span class="fu">rownames</span>(Y_centered)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># define y index</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>y_index <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"># add them to a list for easier access</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>data_merged<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>X_centered,<span class="at">mrna=</span>Y_centered,<span class="at">y=</span>Z_centered)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co"># perform pls</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>block_plsda_results <span class="ot">&lt;-</span> mixOmics<span class="sc">::</span><span class="fu">block.pls</span>(data_merged,<span class="at">indY =</span> y_index,<span class="at">scale =</span> <span class="cn">FALSE</span>,<span class="at">ncomp =</span> <span class="dv">2</span>)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the results</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>mixOmics<span class="sc">::</span><span class="fu">plotIndiv</span>(block_pls_results,<span class="at">group =</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype,<span class="at">ind.names =</span> F,<span class="at">legend =</span> T,<span class="at">blocks =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Now it comes a critical question. Given that we have done regression, meaning that we can only predict continuous values, how can we transform these continuous values to our groups (categorical).</p>
<p>Imagine that we have a single test sample for which we want to predict the class. One way to do so is to project that sample (using the PLS weights) onto the PLS space (scores) and then look what groups of samples are “closer” to the projected sample. We can then assign the closer group label to that sample.</p>
<p>We can do that following this notation:</p>
<ol type="1">
<li>Compute the projection matrix <span class="math inline">\(P\)</span>: <span class="math display">\[
P = X_i^T \cdot V_i
\]</span> where</li>
</ol>
<ul>
<li><span class="math inline">\(X_i\)</span>: the <span class="math inline">\(i\)</span>-th data matrix,</li>
<li><span class="math inline">\(V_i\)</span>: the <span class="math inline">\(i\)</span>-th variates matrix.</li>
</ul>
<ol start="2" type="1">
<li>Compute the weight matrix <span class="math inline">\(W\)</span>: <span class="math display">\[
W = L_i
\]</span> where</li>
</ol>
<ul>
<li><span class="math inline">\(L_i\)</span>: the <span class="math inline">\(i\)</span>-th loadings matrix.</li>
</ul>
<ol start="3" type="1">
<li>Calculate the predicted scores <span class="math inline">\(T_{\text{pred}}\)</span>: <span class="math display">\[
T_{\text{pred},i} = X_{\text{new},i} \cdot W \cdot (P^T \cdot W)^{-1}
\]</span> where</li>
</ol>
<ul>
<li><span class="math inline">\(X_{\text{new},i}\)</span>: the <span class="math inline">\(i\)</span>-th new data matrix to be projected.</li>
</ul>
<ol start="4" type="1">
<li>Normalize the predicted scores: <span class="math display">\[
T_{\text{pred},i} = T_{\text{pred},i} \cdot \text{diag}\left(\|V_{i,j}\|_2^2\right)^{-1}
\]</span> where</li>
</ol>
<ul>
<li><span class="math inline">\(\|V_{i,j}\|_2^2\)</span>: the squared Euclidean norm of the <span class="math inline">\(j\)</span>-th column of <span class="math inline">\(V_i\)</span>,</li>
<li><span class="math inline">\(\text{diag}(\cdot)\)</span>: a diagonal matrix formed from the vector of squared norms.</li>
</ul>
<p>Let’s try to implement that.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-19_cd2edfaef1654772db23531394666aba">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># construct the data</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>data_merged_test<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="at">mirna=</span>breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>mirna[<span class="dv">1</span>,,<span class="at">drop=</span>F],<span class="at">mrna=</span>breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>mrna[<span class="dv">1</span>,,<span class="at">drop=</span>F])</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># center using the training dataset</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>data_merged_test<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged_test), </span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>                  <span class="cf">function</span>(x) {</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">sweep</span>(data_merged_test[[x]], <span class="dv">2</span>, <span class="at">STATS =</span> <span class="fu">attr</span>(data_merged[[x]], </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>                      <span class="st">"scaled:center"</span>))</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>                  })</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(data_merged_test)<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"mirna"</span>,<span class="st">"mrna"</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"># estimate the loadings</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>loading_matrix <span class="ot">=</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged_test),<span class="cf">function</span>(i){</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">crossprod</span>(block_plsda_results<span class="sc">$</span>X[[i]], block_plsda_results<span class="sc">$</span>variates[[i]])</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the weights</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>weights <span class="ot">=</span> block_plsda_results<span class="sc">$</span>loadings[<span class="sc">-</span>y_index]</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate the projection</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>projections <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(data_merged_test),<span class="cf">function</span>(i){</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># unscaleled projection</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  unscaled_prj<span class="ot">&lt;-</span> data_merged_test[[i]]<span class="sc">%*%</span>weights[[i]]<span class="sc">%*%</span><span class="fu">solve</span>(<span class="fu">t</span>(loading_matrix[[i]]) <span class="sc">%*%</span> </span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            weights[[i]])</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculate scaller as 2-norm</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>  scaller<span class="ot">&lt;-</span>   <span class="fu">apply</span>(block_plsda_results<span class="sc">$</span>variates[[i]], <span class="dv">2</span>, <span class="cf">function</span>(y) {</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>                  (<span class="fu">norm</span>(y, <span class="at">type =</span> <span class="st">"2"</span>))<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># rescale the projection</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sweep</span>(unscaled_prj, <span class="dv">2</span>, scaller, <span class="st">"*"</span>)</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the projection  </span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign colors to each subtype</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>colors <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"purple"</span>,<span class="st">"blue"</span>)</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(colors) <span class="ot">&lt;-</span> <span class="fu">levels</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype)</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(block_plsda_results<span class="sc">$</span>variates<span class="sc">$</span>mirna,<span class="at">col=</span>colors[breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype],<span class="at">main=</span><span class="st">"miRNA scores"</span>)</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(projections[[<span class="dv">1</span>]],<span class="at">col=</span><span class="st">"blue"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="dv">3</span>)</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomleft"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="fu">levels</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype),<span class="st">"projected point"</span>), <span class="at">fill=</span>colors, <span class="at">title=</span><span class="st">"Subtype"</span>)</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(block_plsda_results<span class="sc">$</span>variates<span class="sc">$</span>mrna,<span class="at">col=</span>colors[breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype],<span class="at">main=</span><span class="st">"mRNA scores"</span>)</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a><span class="fu">points</span>(projections[[<span class="dv">2</span>]],<span class="at">col=</span><span class="st">"blue"</span>,<span class="at">pch=</span><span class="dv">16</span>,<span class="at">cex=</span><span class="dv">3</span>)</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomleft"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="fu">levels</span>(breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype),<span class="st">"projected point"</span>), <span class="at">fill=</span>colors, <span class="at">title=</span><span class="st">"Subtype"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the plot above, we can see the projection of the test datapoint to the PLS space. <strong>Which group does it blong to? Can you check based on the data if your prediction is correct?</strong></p>
<p>In the similar way, we can predcit whatever number of new samples we want to. We can use distance measurement to automate the process of making predictions.</p>
<p>We now know most of ingredients of PLS, PLS-DA and multiomics data integration using PLS. Now it is time to do some coding and make some conclusions.</p>
</section>
</section>
<section id="supervised-data-integration-using-mixomics" class="level1">
<h1>Supervised data integration using mixOmics</h1>
<p>We are going to focus on supervised data integration here. We will start with classification and then have a quick look at regression later.</p>
<section id="diablo---mixomics" class="level2">
<h2 class="anchored" data-anchor-id="diablo---mixomics">DIABLO - mixOmics</h2>
<p>DIABLO is the name of the method that implements the process that we just went through.</p>
<p>In order to do DIABLO, similar as before we need to create a list which contain our data:</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-20_bb4f7c0419646c1d7474fe6ec48df020">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>training_data <span class="ot">=</span> <span class="fu">list</span>(<span class="at">miRNA =</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mirna, </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">mRNA =</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>mrna)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>Y_training <span class="ot">&lt;-</span> breast.TCGA<span class="sc">$</span>data.train<span class="sc">$</span>subtype</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here we skipped centering etc because DIABLO is going to do that for us.</p>
<p>We need one more thing before doing DIABLO and that is the design matrix. As discuss before:</p>
<p>Think of <code>design</code> as a grid where each cell’s value, ranging from 0 to 1, indicates the strength of the relationship between two corresponding data blocks. A value of 0 means no relationship, while 1 signifies a strong connection. When you’re setting up your analysis, adjusting these values can help you emphasize or de-emphasize certain relationships, giving you the flexibility to focus on specific interactions that are of interest.</p>
<p>Choosing the magnitude of the relationship is not straightforward. It for example can be from previous experiments or so. But generally choosing a very high value will have negative impact on the prediction ability of the model. Choosing a very low value on the other hand will cause discarding the relationship between the data blocks. Here i have randomly chosen to go with <code>0.2</code>. In practice one might want to do Sensitivity Analysis or Cross-Validation to try to optimize this value.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-21_7b3f8a8b52b6439d5c9de6c01cce56a2">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># for square matrix filled with 0.2</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>design <span class="ot">=</span> <span class="fu">matrix</span>(<span class="fl">0.2</span>, <span class="at">ncol =</span> <span class="fu">length</span>(training_data), <span class="at">nrow =</span> <span class="fu">length</span>(training_data), </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">dimnames =</span> <span class="fu">list</span>(<span class="fu">names</span>(training_data), <span class="fu">names</span>(training_data)))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(design) <span class="ot">=</span> <span class="dv">0</span> <span class="co"># set diagonal to 0s</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(design)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      miRNA mRNA
miRNA   0.0  0.2
mRNA    0.2  0.0</code></pre>
</div>
</div>
<p>We can proceed with running the analysis</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-22_14541a19a07d63d251ce69ad4dd27082">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mixOmics)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>diablo.model <span class="ot">=</span> <span class="fu">block.splsda</span>(<span class="at">X =</span> training_data, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> <span class="dv">2</span>, <span class="at">design =</span> design) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Design matrix has changed to include Y; each block will be
            linked to Y.</code></pre>
</div>
</div>
<p>Right now we have a model that includes two components. We can go ahead and visualize the PLS scores.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-23_f19be71adf155e653e803c48bf276a18">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotIndiv</span>(diablo.model,<span class="at">ind.names =</span> F,<span class="at">legend =</span> T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-23-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We see three separate clusters formed in the PLS space in both OMICS. That looks great! But this can be misleading. We need to be able to systematically say how good our model’s performance is before making any interpretation. This means we need to check if we have fitted the data well enough. Or have we actually overfitted the data.</p>
<p>Overfitting occurs when a model is too complex, capturing noise in the training data and making it less effective in generalizing to new, unseen data. It essentially “memorizes” the training data, leading to excellent performance on that specific dataset but poor performance on new data. To mitigate overfitting and evaluate the model’s performance accurately, we employ techniques like cross-validation. Cross-validation involves partitioning the original training data set into a training set and a validation set; the model is trained on the training set and evaluated on the validation set. This process is repeated several times, with different partitions, to obtain a more generalized model performance metric. Techniques like k-fold cross-validation, where the original training set is divided into k subsets and the model is trained k times, each time using a different subset as the validation set, are commonly used. This rigorous evaluation process helps in assessing the model’s ability to generalize, ensuring that it performs well not just on the training data, but on unseen data as well. For more information see <a href="https://nbisweden.github.io/workshop-mlbiostatistics/session-supervise/docs/intro.html">here</a>.</p>
<p>mixOmics provides us with a function (<code>perf</code>) to evaluate the model using cross-validation. We are going to do 10-fold cross-validation and repeat it 10 times. This means that the entire dataset is divided into 10 equal parts, or “folds”. In each iteration, 9 folds are used for training the model, and the remaining fold is used for testing. This process is repeated 10 times, with each fold getting a chance to be the test set. The model’s performance is then averaged over all the iterations to get a more stable and reliable estimate of its performance. Repeating the entire 10-fold cross-validation process 10 times helps in reducing the variability associated with the random splitting of data and provides a more robust measure of the model’s accuracy and generalizability. Each repetition involves a different random split of the data into folds, ensuring diverse training and testing combinations and thus, a comprehensive evaluation.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-24_65901704f9ae0c97496314012ad9cd11">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>diablo.model <span class="ot">=</span> <span class="fu">block.splsda</span>(<span class="at">X =</span> training_data, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> <span class="dv">2</span>, <span class="at">design =</span> design) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Design matrix has changed to include Y; each block will be
            linked to Y.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>perf.diablo <span class="ot">=</span> <span class="fu">perf</span>(diablo.model, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(perf.diablo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-24-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Alright. This plots gives us a lot of information. The colors represent which distance measure has been used to assign groups to the test data. As we discussed we can use different distance measurement to predict the classes from the PLS continuous values. In practice these distances should do very similar but one might want to focus on centroid and mahalanobis distance more.</p>
<p>The type of the line (solid and dashed) shown error rate (ER) and balanced error rate (BER), respectively. Error Rate (ER) is the proportion of incorrect predictions made by the model over the total number of predictions, while Balanced Error Rate (BER) is the average error rates across all classes, ensuring that each class contributes equally to the overall error rate, even if the classes are imbalanced in size. In the plot, different line types allow for an easy visual comparison between these two metrics for each distance measure.</p>
<p>The x-axis represents the number of components included in the model, which is a crucial aspect of PLS-DA. By observing how the error rates change with the inclusion of additional components, one can identify the optimal number of components that minimizes the error rates, striking a balance between model complexity and predictive accuracy.</p>
<p>In evaluating these plots, one should look for the point where both ER and BER are minimized, indicating optimal model performance. Special attention should be given to the results obtained using centroid and Mahalanobis distances, as they often provide a more nuanced and reliable classification, especially in complex multiclass scenarios or when the data distribution is not straightforward. By comparing the error rates associated with different distance measures and numbers of components, one can fine-tune the PLS-DA model for optimal classification performance.</p>
<p><code>perf</code> functions gives a lot of other information but probably the most useful ones are:</p>
<ul>
<li>auc: Averaged AUC values over the nrepeat (if requested)</li>
<li>MajorityVote.error.rate: If more than one block, returns the error rate of the MajorityVote output</li>
</ul>
<p>Have a look at the help page of the function to know more.</p>
<p>Now we know that we do actually fairly good because low error rate, meaning that the model is usable.</p>
<p><strong>Can we make it better? Can you change the design matrix to different values and compare the results of cross-validation?</strong></p>
<section id="tuning-number-of-components" class="level3">
<h3 class="anchored" data-anchor-id="tuning-number-of-components">Tuning number of components</h3>
<p>I guess you also asked yourself why we should use two components. Maybe we can go higher? or maybe lower? we can try to tune this quick simply by include more components in the model and redo the cross-validation</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-25_54ceb27d41e106e4b78099af977de0d5">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>diablo.model <span class="ot">=</span> <span class="fu">block.splsda</span>(<span class="at">X =</span> training_data, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> <span class="dv">5</span>, <span class="at">design =</span> design) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Design matrix has changed to include Y; each block will be
            linked to Y.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>perf.diablo <span class="ot">=</span> <span class="fu">perf</span>(diablo.model, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(perf.diablo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This is the same plot as before but now we have more component on the x-axis. What this plot tells us that the error rate sharply decreases from ~0.3 to 0.1 just by including two components instead of one. Then we have smaller decrease from component two to three. After that the improvment is very little. So perhaps we should use 3 components or should we use five? This is where the trade-off between model complexity and performance comes into play. While adding more components can lead to a slight decrease in error rate, it also increases the complexity of the model, which can lead to more difficulty in interpretation etc. So we should go for the least complex model that gives us a reasonable error rate.</p>
<p>mixOmics gives us an automated way of selecting the best compoent. We can see mixOmics choice using:</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-26_c40ac73415f3b325f882a4cb16b8b28f">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(perf.diablo<span class="sc">$</span>choice.ncomp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$AveragedPredict
            [,1]
Overall.ER     4
Overall.BER    4

$WeightedPredict
            [,1]
Overall.ER     3
Overall.BER    3

$MajorityVote
            max.dist centroids.dist mahalanobis.dist
Overall.ER         5              3                3
Overall.BER        4              3                3

$WeightedVote
            max.dist centroids.dist mahalanobis.dist
Overall.ER         3              3                4
Overall.BER        3              3                4</code></pre>
</div>
</div>
<p>I this case, we are going to use majority vote and <code>mahalanobis.dist</code> so we we choose three components and redo the analysis.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-27_0cb3f22bd0c9db9b11227969e2108ae2">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>ncomps <span class="ot">&lt;-</span> perf.diablo<span class="sc">$</span>choice.ncomp<span class="sc">$</span>MajorityVote[<span class="st">"Overall.BER"</span>,<span class="st">"centroids.dist"</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>diablo.model <span class="ot">=</span> <span class="fu">block.splsda</span>(<span class="at">X =</span> training_data, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> ncomps, <span class="at">design =</span> design) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Design matrix has changed to include Y; each block will be
            linked to Y.</code></pre>
</div>
</div>
</section>
<section id="variable-selection" class="level3">
<h3 class="anchored" data-anchor-id="variable-selection">Variable selection</h3>
<p>We now have a working model with a reasonably low error rate. We can use this model to extract the most important features (eg., transcripts) that gave us such a discriminatory pattern we saw in the score plots.</p>
<p>We should do that three times in fact. One for each components. We have one set of loading for each component and for each block of data. it is quite a lot of work to go through these loadings. In the following plots, the bars have a color corresponding the group which has the maximum (<code>max</code> in contrib) of average (<code>mean</code> in method) among all the groups.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-28_2f4918fb2d27b2e824212db2cd66efc7">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotLoadings</span>(diablo.model,<span class="at">comp=</span><span class="dv">1</span>,<span class="at">contrib=</span><span class="st">'max'</span>,<span class="at">method=</span><span class="st">'mean'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotLoadings</span>(diablo.model,<span class="at">comp=</span><span class="dv">2</span>,<span class="at">contrib=</span><span class="st">'max'</span>,<span class="at">method=</span><span class="st">'mean'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-28-2.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotLoadings</span>(diablo.model,<span class="at">comp=</span><span class="dv">3</span>,<span class="at">contrib=</span><span class="st">'max'</span>,<span class="at">method=</span><span class="st">'mean'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-28-3.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Similar to what we said before, the most important variables (according to the absolute value of their coefficients) are ordered from bottom to top. One can go ahead and examine top x (eg. top 10) variables. They have the same interpretation as before: Bars extending to the right represent features that are positively correlated with PC1, indicating that as the values of these features increase, so does the score of corresponding component Conversely, bars extending to the left suggest a negative correlation, meaning as the values of these features increase, the score of the component decreases.</p>
<p>In this specific example we have a limited number of features so it might be feasible to do it manually. However, in practice most omics datasets are large and that will make it very difficult to choose a right cutoff to select the number of features per omics.</p>
<p>Fortunately, mixOmics gives us an automated way of selecting variables using <code>tune.block.splsda</code> function. The only thing we have to do is to select the possible a grid of values for each component to test. mixOmics will then do cross-validation and try to give us the most influential variables on the model and discard the rest. This means that, given a vector of possible number of variables, the function will pinpoint the optimal subset that contributes the most to our model’s predictive power, ensuring both efficiency and accuracy in our analysis.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-29_ea211c9f92b6e712572988b7489bd957">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set grid of values for each component to test</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>test.keepX <span class="ot">=</span> <span class="fu">list</span> (<span class="at">mirna =</span><span class="fu">seq</span>(<span class="dv">10</span>, <span class="dv">18</span>, <span class="dv">2</span>),</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">mrna =</span> <span class="fu">seq</span>(<span class="dv">10</span>, <span class="dv">18</span>, <span class="dv">2</span>))</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>                   </span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co"># run the feature selection tuning</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>tune.TCGA <span class="ot">=</span> <span class="fu">tune.block.splsda</span>( training_data, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> ncomps, </span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>                              <span class="at">test.keepX =</span> test.keepX, <span class="at">design =</span> design,</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>                              <span class="at">validation =</span> <span class="st">'Mfold'</span>, <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">1</span>,</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>                              <span class="at">dist =</span> <span class="st">"centroids.dist"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Design matrix has changed to include Y; each block will be
            linked to Y.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
You have provided a sequence of keepX of length: 5 for block mirna and 5 for block mrna.
This results in 25 models being fitted for each component and each nrepeat, this may take some time to run, be patient!</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
You can look into the 'BPPARAM' argument to speed up computation time.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(tune.TCGA)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-29-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This barplot can help us seeing the process of variable selection. In each component the x-axis is BER and y-axis is the combiniton of the number of selected variable in omics1 (mirna) and omics2 (mrna) which has been written as omics1_omics2 (for example 10_12 means 10 variables from <code>mirna</code> and 12 variables from <code>mrna</code> block). Again we are going to look for the least complex (fewer variables) model with lower BER. In component one the top 5 selections are in the top of the plot, the least numbers among them is <code>10_16</code>, similarly we can select <code>10_14</code> for the second component and <code>10_18</code> for the last one. mixOmics also gives us these numbers in <code>choice.keepX</code> list.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-30_6a35f5df339428275e820e150a79b3a1">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(tune.TCGA<span class="sc">$</span>choice.keepX)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$miRNA
[1] 10 10 10

$mRNA
[1] 16 14 18</code></pre>
</div>
</div>
<p>Now that we have the number of variables we can go ahead and do the final model:</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-31_69dfb7049cdbaeeb1c9f9ee5f5ec393c">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># set the optimised DIABLO model</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>final.diablo.model <span class="ot">=</span> <span class="fu">block.splsda</span>(training_data, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> ncomps,</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">keepX =</span> tune.TCGA<span class="sc">$</span>choice.keepX, <span class="at">design =</span> design)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Design matrix has changed to include Y; each block will be
            linked to Y.</code></pre>
</div>
</div>
<p>Now for each components we can see which variables have been selected. For exmple for component 1.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-32_159ed552ea691e42bcaf5e85b2b19c29">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">selectVar</span>(final.diablo.model, <span class="at">block =</span> <span class="st">'miRNA'</span>, <span class="at">comp =</span> <span class="dv">1</span>)<span class="sc">$</span>miRNA<span class="sc">$</span>name </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "hsa-mir-17"   "hsa-mir-505"  "hsa-mir-590"  "hsa-mir-130b" "hsa-mir-20a" 
 [6] "hsa-mir-106a" "hsa-mir-106b" "hsa-mir-197"  "hsa-mir-186"  "hsa-let-7d"  </code></pre>
</div>
</div>
<p><strong>what are the variables for mRNA?</strong></p>
<p>Should we go ahead with these variables? Well, maybe! We need to do another performance check of the final model.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-33_1f06b55ca00e466d17b22c170f37bc9c">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>perf.diablo <span class="ot">=</span> <span class="fu">perf</span>(final.diablo.model, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(perf.diablo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-33-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>So based on what we see, we are seeing similar performance using only maximum of 18 variables. However, please note that these variables are not fixed when doing cross-validation. This means that different subsets of variables might be selected in different folds of the cross-validation, leading to variability in the selected features. This variability underscores the importance of feature stability, a crucial aspect to consider when evaluating the reliability of the selected features. It’s not just about how well the model performs, but also about how consistent the selected features are across different subsets of the data.</p>
<p>Moving towards variable stability, it becomes essential to assess the robustness of the selected variables. Are these variables consistently selected across different folds and repetitions of cross-validation? If a variable is often selected, it indicates that its inclusion in the model is not a product of random chance or specific to a particular subset of data, enhancing our confidence in its relevance and reliability.</p>
<p>In the context of mixOmics and DIABLO, the perf function provides insights into feature stability. By examining the stability scores, we can identify which features are consistently selected across multiple iterations of the model fitting process. A higher stability score indicates that a feature is consistently chosen across different folds and repetitions, marking it as a reliable variable that contributes significantly to the model’s predictive power.</p>
<p>Let’s visualize this stability to have a clearer insight into the consistency of feature selection. We will plot the stability scores for each feature across all components and omics, giving us a comprehensive view of which features are most stable and potentially the most biologically relevant for further investigation.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-34_60d9c5d0db91f50eeea90085a196ae34">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a> all_reps <span class="ot">&lt;-</span> perf.diablo<span class="sc">$</span>features<span class="sc">$</span>stable</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the union of all features across all repetitions for each component</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>all_features_comp1 <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(union, <span class="fu">lapply</span>(all_reps, <span class="cf">function</span>(x) <span class="fu">names</span>(x<span class="sc">$</span>miRNA<span class="sc">$</span>comp1)))</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>all_features_comp2 <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(union, <span class="fu">lapply</span>(all_reps, <span class="cf">function</span>(x) <span class="fu">names</span>(x<span class="sc">$</span>miRNA<span class="sc">$</span>comp2)))</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>all_features_comp3 <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(union, <span class="fu">lapply</span>(all_reps, <span class="cf">function</span>(x) <span class="fu">names</span>(x<span class="sc">$</span>miRNA<span class="sc">$</span>comp3)))</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to fill in missing features with zeros</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>fill_missing_features <span class="ot">&lt;-</span> <span class="cf">function</span>(stability_scores, all_features) {</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>  filled_scores <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">length</span>(all_features))</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(filled_scores) <span class="ot">&lt;-</span> all_features</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  filled_scores[<span class="fu">names</span>(stability_scores)] <span class="ot">&lt;-</span> stability_scores</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(filled_scores)</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Combining the stability scores for each feature across all repetitions and filling in missing features with zeros</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>combined_stability_miRNA_comp1 <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(<span class="st">'+'</span>, <span class="fu">lapply</span>(all_reps, <span class="cf">function</span>(x) </span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_missing_features</span>(x<span class="sc">$</span>miRNA<span class="sc">$</span>comp1, all_features_comp1))) <span class="sc">/</span> <span class="fu">length</span>(all_reps)</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>combined_stability_miRNA_comp2 <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(<span class="st">'+'</span>, <span class="fu">lapply</span>(all_reps, <span class="cf">function</span>(x) </span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_missing_features</span>(x<span class="sc">$</span>miRNA<span class="sc">$</span>comp2, all_features_comp2))) <span class="sc">/</span> <span class="fu">length</span>(all_reps)</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>combined_stability_miRNA_comp3 <span class="ot">&lt;-</span> <span class="fu">Reduce</span>(<span class="st">'+'</span>, <span class="fu">lapply</span>(all_reps, <span class="cf">function</span>(x) </span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_missing_features</span>(x<span class="sc">$</span>miRNA<span class="sc">$</span>comp3, all_features_comp3))) <span class="sc">/</span> <span class="fu">length</span>(all_reps)</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting the combined stability scores</span></span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))</span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Component 1</span></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a><span class="fu">barplot</span>(combined_stability_miRNA_comp1, <span class="at">main=</span><span class="st">"miRNA - Component 1"</span>, </span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlab=</span><span class="st">"Features"</span>, <span class="at">ylab=</span><span class="st">"Combined Stability"</span>, <span class="at">las=</span><span class="dv">2</span>, <span class="at">cex.names=</span><span class="fl">0.7</span>)</span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Component 2</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a><span class="fu">barplot</span>(combined_stability_miRNA_comp2, <span class="at">main=</span><span class="st">"miRNA - Component 2"</span>, </span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlab=</span><span class="st">"Features"</span>, <span class="at">ylab=</span><span class="st">"Combined Stability"</span>, <span class="at">las=</span><span class="dv">2</span>, <span class="at">cex.names=</span><span class="fl">0.7</span>)</span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Component 3</span></span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a><span class="fu">barplot</span>(combined_stability_miRNA_comp3, <span class="at">main=</span><span class="st">"miRNA - Component 3"</span>, </span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>        <span class="at">xlab=</span><span class="st">"Features"</span>, <span class="at">ylab=</span><span class="st">"Combined Stability"</span>, <span class="at">las=</span><span class="dv">2</span>, <span class="at">cex.names=</span><span class="fl">0.7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-34-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the plots we’ve generated, each bar represents a specific feature from the omics data, and the height of the bar corresponds to the stability score of that feature. A higher bar indicates that the feature is consistently selected across different folds and repetitions of cross-validation, suggesting it is a robust and reliable feature in the context of our model.</p>
<p>As we examine these plots, we’re particularly interested in features with higher stability scores. These are the features that have shown to be consistently important regardless of the specific data subset used for training, indicating their pivotal role in the model’s predictive capability. Each plot corresponds to a different component and omics data type, allowing us to dissect the contribution of each feature in a multi-faceted manner.</p>
<p>To interpret these plots effectively, focus on identifying features with the highest stability scores across multiple components. These features are not only influential in explaining the variance in the data but are also consistent in their performance, making them prime candidates for further biological investigation. Additionally, comparing the stability of features across different omics data types can provide insights into the integrative nature of the model, highlighting features that contribute to a comprehensive understanding of the underlying biological processes.</p>
</section>
<section id="final-model-and-further-investiations" class="level3">
<h3 class="anchored" data-anchor-id="final-model-and-further-investiations">Final model and further investiations</h3>
<p>We finally have our fantastic model ready. it gave us good performance.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-35_50602b009cc7828569b55866c09bb2ce">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotIndiv</span>(final.diablo.model, <span class="at">ind.names =</span> <span class="cn">FALSE</span>, <span class="at">legend =</span> <span class="cn">TRUE</span>, </span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">title =</span> <span class="st">'DIABLO Sample Plots'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-35-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Visual inspection of the scores reveals a pronounced separation between the three cancer subtypes, suggesting that our selected variables hold significant discriminatory power. We can have a look at how these variables influence the shared space:</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-36_9ee0f07c783f8d47cabb5c3014344c0d">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plotVar</span>(final.diablo.model,<span class="at">var.names=</span><span class="cn">TRUE</span>,<span class="at">legend=</span><span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-36-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>This is Correlation Circle Plot, a visual representation that overlays the loadings (from variables) from each omic layer. In this plot, when variables cluster near each other specially closer to the poles, it indicates a strong correlation among them, even if they originate from different omic layers. Conversely, variables positioned on opposing poles suggest a strong negative correlation. Correlation Circle Plot offers insights into feature-level interactions, revealing the relationships among variables across different omic layers.</p>
<p>While integration has allowed us to construct this shared space and see the top variables, its true potential lies in understanding the the interactions among the variables. To go deeper into these interactions and uncover the underlying network of relationships, we can utilize mixOmics’ <code>network</code> visualization and the <code>cim</code> function, offering a comprehensive view of how these features interplay across different omics layers.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-37_a9933caed0c586de5f791ca677f373cf">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>mixOmics_graph<span class="ot">&lt;-</span><span class="fu">network</span>(final.diablo.model, <span class="at">cutoff =</span> <span class="fl">0.5</span>,</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="at">color.node =</span> <span class="fu">c</span>(<span class="st">"gold"</span>, <span class="st">"tomato"</span>),</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="at">shape.node =</span> <span class="fu">c</span>(<span class="st">"rectangle"</span>, <span class="st">"circle"</span>),</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">#color.edge = color.spectral(100),</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="at">lty.edge =</span> <span class="st">"solid"</span>, <span class="at">lwd.edge =</span>  <span class="dv">1</span>,<span class="at">cex.node.name =</span> <span class="fl">0.4</span>,</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="at">show.edge.labels =</span> T, <span class="at">interactive =</span> <span class="cn">FALSE</span>,<span class="at">graph.scale =</span> <span class="fl">0.3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-37-1.png" style="width:70.0%;height:70.0%"></p>
</div>
</div>
<p>The above network is simply the results of calculating the correlation between the variables in the loadings space. We have selected to put the correlation cutoff on <code>0.7</code>, resulting removing the variables that have no edges (lines).</p>
<p>The correlation between the variables in the loading space is calculated based on their loadings. Mathematically, this can be represented as:</p>
<p><span class="math display">\[ \text{Corr}(X_i, Y_j) = \frac{\sum_{k=1}^n (X_{ik} - \bar{X_i})(Y_{jk} - \bar{Y_j})}{\sqrt{\sum_{k=1}^n (X_{ik} - \bar{X_i})^2 \sum_{k=1}^n (Y_{jk} - \bar{Y_j})^2}} \]</span></p>
<p>where <span class="math inline">\(X_i\)</span> and <span class="math inline">\(Y_j\)</span> are the loading vectors of variables <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, <span class="math inline">\(X_{ik}\)</span> and <span class="math inline">\(Y_{jk}\)</span> are the individual loading coefficients at position <span class="math inline">\(k\)</span>, and <span class="math inline">\(\bar{X_i}\)</span> and <span class="math inline">\(\bar{Y_j}\)</span> are the means of the loading vectors.</p>
<p>However, in the context of PLS, the loadings are normalized, meaning that their lengths are equal to 1. This simplifies the correlation calculation to the dot product of the loading vectors:</p>
<p><span class="math display">\[ \text{Corr}(X_i, Y_j) = X_i \cdot Y_j \]</span></p>
<p>This dot product gives a value between -1 and 1, representing the correlation between the two variables in the latent space. A value close to 1 indicates a strong positive correlation, a value close to -1 indicates a strong negative correlation, and a value around 0 indicates no correlation.</p>
<p>In the network visualization, these correlation values are represented as edges connecting the nodes (variables). The strength and direction of the correlation determine the thickness and color of the edges, providing a visual representation of the relationships among variables across different omics data types. This aids in identifying groups of variables that are potentially functionally related and offers insights into the underlying biological processes.</p>
<p>This plot can be used to group the features together, see their interaction and use that for example to do joint pathway analysis or similar.</p>
<section id="clustering-the-relevent-variables" class="level4">
<h4 class="anchored" data-anchor-id="clustering-the-relevent-variables">Clustering the relevent variables</h4>
<p>The network function by mixOmics provides convenience when it comes to visualization but in order to perform a much more flexible analysis we would need to construct the network ourselves. We do that using the provide formula above but instead of calculating the correlations across data views, we are going to calculate it both within and across datasets so we can do clustering. We are also going to put a cutoff of 0.5 correlation, so everthing with absolute correlation lower than 0.5 is set to zero.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-38_515fc125eede4c7d81ea477d7ca321bf">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>components <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate loadings for the selected variables</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>ind_cord<span class="ot">&lt;-</span><span class="fu">mapply</span>(<span class="cf">function</span>(x,y,z){<span class="fu">cor</span>(x[,<span class="fu">apply</span>(<span class="fu">abs</span>(z[,components]),<span class="dv">1</span>,sum)<span class="sc">&gt;</span><span class="dv">0</span>],y[,components,<span class="at">drop=</span>F],<span class="at">use =</span> <span class="st">"p"</span>)},</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">x=</span>final.diablo.model<span class="sc">$</span>X[<span class="sc">-</span><span class="dv">3</span>],<span class="at">y=</span>final.diablo.model<span class="sc">$</span>variates[<span class="sc">-</span><span class="dv">3</span>],<span class="at">z=</span>final.diablo.model<span class="sc">$</span>loadings[<span class="sc">-</span><span class="dv">3</span>])</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate cross-correlation matrix</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>all_loadings<span class="ot">&lt;-</span>(<span class="fu">rbind</span>(ind_cord<span class="sc">$</span>miRNA,ind_cord<span class="sc">$</span>mRNA))</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>correaltions<span class="ot">&lt;-</span>all_loadings<span class="sc">%*%</span><span class="fu">t</span>(all_loadings)</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="co"># set uninteresting correlation to zero</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>correaltions[<span class="fu">abs</span>(correaltions)<span class="sc">&lt;</span><span class="fl">0.5</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We often need to use dissimlarity or sometime weights to perform clustering. Correlations are not a good measure to do clustering. We are going to use <span class="math inline">\(\sqrt{2\times 1- r}\)</span> formula to transform the correlations to distances.We then use gaussian similarity function (<span class="math inline">\(\text{Similarity}(i, j) = \exp\left(-\frac{\text{Distance}(i, j)^2}{2\sigma^2}\right)\)</span>) to convert distances into similarities, ensuring that the similarities are positive and bounded between 0 and 1.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-39_9639ba7608390202944119a3672c98e5">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convert to distance</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>correaltions <span class="ot">&lt;-</span><span class="fu">sqrt</span>(<span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> correaltions))</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co"># convert to similarities</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="dv">1</span> </span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>similarity_matrix <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="sc">-</span>correaltions<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> (<span class="dv">2</span> <span class="sc">*</span> sigma<span class="sc">^</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Given the similarity we can now create the graph using <code>igraph</code> package and perform community detection.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-40_6d00bd45b246a299ef6170c4a1917537">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a graph from an adjacency matrix with weighted edges</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">graph_from_adjacency_matrix</span>(similarity_matrix, <span class="at">weighted =</span> <span class="cn">TRUE</span>, <span class="at">diag =</span> <span class="cn">FALSE</span>)</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the graph to an undirected graph and combine edge attributes randomly</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">as.undirected</span>(g, <span class="at">edge.attr.comb =</span> <span class="st">"random"</span>)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a><span class="co"># remove edges with zero (transformed) correlation</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">delete.edges</span>(g, <span class="fu">which</span>(<span class="fu">E</span>(g)<span class="sc">$</span>weight <span class="sc">==</span><span class="fu">exp</span>(<span class="sc">-</span><span class="fu">sqrt</span>(<span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> <span class="dv">0</span>))<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> (<span class="dv">2</span> <span class="sc">*</span> sigma<span class="sc">^</span><span class="dv">2</span>))))</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove isolated vertices (nodes with degree 0)</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>Isolated <span class="ot">=</span> <span class="fu">which</span>(<span class="fu">degree</span>(g) <span class="sc">==</span> <span class="dv">0</span>)</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span><span class="fu">delete.vertices</span>(g, Isolated)</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign group labels based on node names</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>group <span class="ot">&lt;-</span> <span class="fu">V</span>(g)<span class="sc">$</span>name</span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>group[<span class="fu">V</span>(g)<span class="sc">$</span>group <span class="sc">%in%</span> <span class="fu">rownames</span>(final.diablo.model<span class="sc">$</span>loadings<span class="sc">$</span>miRNA)] <span class="ot">&lt;-</span> <span class="st">"miRNA"</span></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>group[<span class="fu">V</span>(g)<span class="sc">$</span>group <span class="sc">%in%</span> <span class="fu">rownames</span>(final.diablo.model<span class="sc">$</span>loadings<span class="sc">$</span>mRNA)] <span class="ot">&lt;-</span> <span class="st">"mRNA"</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Define node and edge colors, sizes, and other attributes</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>colrs <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"gray50"</span>, <span class="st">"darkgreen"</span>)</span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>rbPal <span class="ot">&lt;-</span> <span class="fu">colorRampPalette</span>(<span class="fu">c</span>(<span class="st">'red'</span>, <span class="st">'blue'</span>))</span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(g)<span class="sc">$</span>color <span class="ot">&lt;-</span> <span class="fu">rbPal</span>(<span class="dv">10</span>)[<span class="fu">as.numeric</span>(<span class="fu">cut</span>(<span class="fu">E</span>(g)<span class="sc">$</span>weight, <span class="at">breaks =</span> <span class="dv">10</span>))]</span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>color <span class="ot">&lt;-</span> colrs[<span class="fu">as.factor</span>(<span class="fu">V</span>(g)<span class="sc">$</span>group)]</span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>size <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>label.color <span class="ot">&lt;-</span> <span class="st">"black"</span></span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>label <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true" tabindex="-1"></a><span class="fu">E</span>(g)<span class="sc">$</span>width <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true" tabindex="-1"></a><span class="co"># do clustering</span></span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true" tabindex="-1"></a>clusters <span class="ot">&lt;-</span> <span class="fu">cluster_louvain</span>(g)</span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the graph</span></span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true" tabindex="-1"></a><span class="fu">plot.igraph</span>(g,<span class="at">mark.groups =</span> clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-40-1.png" style="width:70.0%;height:70.0%"></p>
</div>
</div>
<p>Where we constructed a graph from an adjacency matrix and then cleaned it by removing specific edges and isolated vertices. The nodes are then labeled and categorized, and attributes are assigned to both nodes and edges for better visualization.</p>
<p>At this stage, we want to do clustering. In graph terminology, this is called community detection. A community is a group of nodes that are more connected to each other than to nodes outside the group. There are many algorithms for community detection, but here we have selected to go with <code>Louvain</code>.</p>
<p>The detection of communities using the Louvain algorithm involves an iterative process of optimizing modularity (we will come back to this in a second!). Modularity is a measure that quantifies the quality of an assignment of nodes to communities by comparing the density of links within communities to links between communities. In short, the Louvain algorithm starts with each node assigned to its own community. It then proceeds in two phases that are repeated iteratively. In the first phase, for each node, the algorithm evaluates the gain in modularity that would result from removing the node from its current community and placing it into a neighboring community. The node is then placed in the community for which this gain is maximized, if there is a positive gain. This process is repeated for all nodes until no further improvement in modularity can be achieved.</p>
<p>In the second phase, the algorithm builds a new network whose nodes are the communities found in the first phase. Links between these new nodes are established by summing the weights of links between nodes in the corresponding communities of the original network. The weight of the links within the new communities is given by the total weight of the links between the nodes within those communities in the original network. The algorithm then returns to the first phase and repeats the process on this new network of communities, and these two phases are iteratively repeated until there is no further improvement in modularity.</p>
<p>The Louvain algorithm is known for its efficiency and is capable of handling large networks. It often reveals hierarchical structures within networks by breaking down larger communities into smaller, more tightly knit groups in successive iterations.</p>
<p>Modularity is a metric that quantifies the strength of division of a network into communities. It measures the density of links inside communities as compared to links between communities. The formula for modularity is <span class="math inline">\(Q = \frac{1}{2m} \sum_{ij} \left( A_{ij} - \frac{k_i k_j}{2m} \right) \delta(c_i, c_j)\)</span>, where <span class="math inline">\(A_{ij}\)</span> is the element of the adjacency matrix (1 if there is a link between node <span class="math inline">\(i\)</span> and node <span class="math inline">\(j\)</span>, and 0 otherwise), <span class="math inline">\(k_i\)</span> and <span class="math inline">\(k_j\)</span> are the degrees of nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, <span class="math inline">\(m\)</span> is the total number of links in the network, <span class="math inline">\(c_i\)</span> and <span class="math inline">\(c_j\)</span> are the communities of the nodes, and <span class="math inline">\(\delta\)</span> is the Kronecker delta function that is 1 if <span class="math inline">\(c_i = c_j\)</span> and 0 otherwise. In simpler terms, modularity compares the number of links within communities to the number expected randomly, with higher values indicating stronger community structure. It is widely used in network science to evaluate the effectiveness of community detection algorithms, helping to identify the network’s underlying structure and to understand the organization and function of complex networks.</p>
<p>Now we have a graph, a list of clusters (communities) and a way to say how good the clustering is <code>modularity</code> but one thing remains that is how good the modularity score actually is? One way to address this, is to compare the modularity to a set of modularity scores from randomly created graph and then say how often a random graph gives better modularity compare to our original graph. This frequency is going to give us a p-value for our modularity.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-41_0be114bc94701f4a335baae8572c4b13">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the modularity of the original network</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>modularity_original <span class="ot">&lt;-</span> <span class="fu">modularity</span>(clusters)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate random networks and compute their modularity</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>n_random_networks <span class="ot">&lt;-</span> <span class="dv">1000</span>  <span class="co"># Number of random networks to generate</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>modularities_random <span class="ot">&lt;-</span> <span class="fu">numeric</span>(n_random_networks)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_random_networks) {</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Generate a random network with the same size and degree distribution as the original network</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(i)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  g_random <span class="ot">&lt;-</span> <span class="fu">rewire</span>(g, <span class="fu">keeping_degseq</span>())</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute the community structure of the random network</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>  clusters_random <span class="ot">&lt;-</span> <span class="fu">cluster_louvain</span>(g_random)</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute the modularity of the random network</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>  modularities_random[i] <span class="ot">&lt;-</span> <span class="fu">modularity</span>(clusters_random)</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(modularities_random,<span class="at">xlim =</span> <span class="fu">c</span>(<span class="fu">min</span>(modularities_random),<span class="fu">max</span>(<span class="fu">c</span>(modularity_original<span class="fl">+0.07</span>,<span class="fu">max</span>(modularities_random)))))</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span>modularity_original,<span class="at">col=</span><span class="st">"red"</span>)</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">x=</span>modularity_original,<span class="at">y=</span><span class="dv">20</span>,<span class="st">"original modularity"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-41-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The the code above, we created 1000 random graphs and calculated modularity for each. <strong>Do you think our communities is better than random?</strong></p>
<p>We can calculate the frequency that random modularities are higher than our original modularity, giving us a p-value.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-42_45b6dfab8faf001d51db2c12428b8272">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare the modularity of the original network with that of the random networks</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>p_value <span class="ot">&lt;-</span> <span class="fu">mean</span>(modularities_random <span class="sc">&gt;=</span> modularity_original)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With a p-value of 0 we are now more confident in our community analysis. Let’s try to visualize these variables in the correlation plot we saw before:</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-43_29038c92d43beeb152c40c32333cd0a4">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Your existing plot command</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(all_loadings[clusters<span class="sc">$</span>names,], </span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">col=</span>clusters<span class="sc">$</span>membership, </span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">pch=</span><span class="fu">as.numeric</span>(<span class="fu">as.factor</span>(<span class="fu">V</span>(g)<span class="sc">$</span>group)))</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding a color legend for clusters</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"topright"</span>,                      <span class="co"># Position of the legend on the plot</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>       <span class="at">legend=</span><span class="fu">unique</span>(clusters<span class="sc">$</span>membership), <span class="co"># Unique cluster IDs</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>       <span class="at">fill=</span><span class="fu">unique</span>(clusters<span class="sc">$</span>membership),   <span class="co"># Colors corresponding to cluster IDs</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>       <span class="at">title=</span><span class="st">"Membership"</span>)               <span class="co"># Title of the legend</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">"bottomright"</span>,                   <span class="co"># Position of the second legend on the plot</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>       <span class="at">legend=</span><span class="fu">levels</span>(<span class="fu">as.factor</span>(<span class="fu">V</span>(g)<span class="sc">$</span>group)), <span class="co"># Unique group names</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>       <span class="at">pch=</span><span class="fu">unique</span>(<span class="fu">as.numeric</span>(<span class="fu">as.factor</span>(<span class="fu">V</span>(g)<span class="sc">$</span>group))), <span class="co"># Point characters for each group</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>       <span class="at">title=</span><span class="st">"Data View"</span>)                   <span class="co"># Title of the second legend</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-43-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The clustering makes a lot of sense. The variables with similar direction of contribution have been clusters together meaning that they have similar effect on the score pattern we observed before. We can also have a look at the scaled expression pattern:</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-44_99c8a1b15ba8e5d16186be7e256ae222">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine legends and colors</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>combined_legend <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">levels</span>(final.diablo.model<span class="sc">$</span>Y), <span class="fu">as.character</span>(<span class="fu">unique</span>(clusters<span class="sc">$</span>membership)))</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>combined_colors <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">unique</span>(<span class="fu">as.numeric</span>(final.diablo.model<span class="sc">$</span>Y)), <span class="fu">unique</span>(clusters<span class="sc">$</span>membership))</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the combined legend parameter</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>legend_param <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">legend =</span> combined_legend, <span class="co"># Combined legend for each group</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">col =</span> combined_colors,    <span class="co"># Combined color vector</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">title =</span> <span class="st">"Combined Legend"</span>,<span class="co"># Title of the legend</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">cex =</span> <span class="fl">0.8</span>                 <span class="co"># Size of the legend items</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Call the cim() function with the combined legend parameter</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a><span class="fu">cim</span>(<span class="fu">cbind</span>(final.diablo.model<span class="sc">$</span>X<span class="sc">$</span>miRNA, final.diablo.model<span class="sc">$</span>X<span class="sc">$</span>mRNA)[,clusters<span class="sc">$</span>names], </span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">col.sideColors =</span> clusters<span class="sc">$</span>membership,</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">row.sideColors =</span> <span class="fu">as.numeric</span>(final.diablo.model<span class="sc">$</span>Y),</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">legend =</span> legend_param)  <span class="co"># Add the combined legend parameter here</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="mixomics_files/figure-html/unnamed-chunk-44-1.png" style="width:70.0%;height:70.0%"></p>
</div>
</div>
<p>We can see a clear expression differences between the cluster 1 and 3 specially between the group Basal and LumA. From this step one can go forward with doing pathway analysis or directly interpret the results. We are going to move on to another important functionality of mixOmics</p>
</section>
<section id="use-the-model-to-predict-new-cases" class="level4">
<h4 class="anchored" data-anchor-id="use-the-model-to-predict-new-cases">Use the model to predict new cases</h4>
<p>Now that we have the model, we can use it to predict new data (unseen by the model)</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-45_1421c5b135ee2856b2cd6a1cfa1e8e6b">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>test_data <span class="ot">=</span> <span class="fu">list</span>(<span class="at">miRNA =</span> breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>mirna, </span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">mRNA =</span> breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>mrna)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>predicted_class_test <span class="ot">&lt;-</span> mixOmics<span class="sc">:::</span><span class="fu">predict.mint.splsda</span>(final.diablo.model,test_data)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>pred_classes_test<span class="ot">&lt;-</span>predicted_class_test<span class="sc">$</span>WeightedVote<span class="sc">$</span>centroids.dist[,<span class="dv">3</span>]</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>readl_classes_test <span class="ot">&lt;-</span> breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>subtype</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a confusion matrix</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="ot">&lt;-</span> <span class="fu">table</span>(readl_classes_test, pred_classes_test)</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the class error rates</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>class_error <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">diag</span>(conf_matrix) <span class="sc">/</span> <span class="fu">rowSums</span>(conf_matrix)</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the overall error rate</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>overall_error_rate <span class="ot">&lt;-</span> (<span class="fu">sum</span>(conf_matrix) <span class="sc">-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(conf_matrix))) <span class="sc">/</span> <span class="fu">sum</span>(conf_matrix)</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"BER:"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "BER:"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">mean</span>(class_error))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.04444444</code></pre>
</div>
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Overall"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Overall"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(overall_error_rate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.05714286</code></pre>
</div>
</div>
<p>This error rate is very good. So our model performs reasonably.</p>
</section>
<section id="was-integration-successful" class="level4">
<h4 class="anchored" data-anchor-id="was-integration-successful">Was integration successful</h4>
<p>We do integration for different purposes. Here we used both for prediction of cancer suptypes and also for clustering the variables. In the case of the cancer suptypes prediction, we might want to ask the question if integration is neccsary or not?</p>
<p>We are going to test this by first doing separate PLSDA on each omics and compare the performance to the integrated one. So we are trying to do everything as similar as possible and check the error rates.</p>
<div class="cell" data-hash="mixomics_cache/html/unnamed-chunk-46_54ba18ea04dac27d7817cbe190a48616">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>miRNA_plsda <span class="ot">&lt;-</span> <span class="fu">splsda</span>(training_data<span class="sc">$</span>miRNA,Y_training,<span class="at">ncomp =</span> <span class="dv">5</span>)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>perf.diablo_miRNA_plsda <span class="ot">=</span> <span class="fu">perf</span>(miRNA_plsda, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>mRNA_plsda <span class="ot">&lt;-</span> <span class="fu">splsda</span>(training_data<span class="sc">$</span>mRNA,Y_training,<span class="at">ncomp =</span> <span class="dv">5</span>)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>perf.diablo_mRNA_plsda <span class="ot">=</span> <span class="fu">perf</span>(mRNA_plsda, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="co"># set grid of values for each component to test</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>test.keepX <span class="ot">=</span> <span class="fu">list</span> (<span class="at">mirna =</span><span class="fu">seq</span>(<span class="dv">10</span>, <span class="dv">18</span>, <span class="dv">2</span>),</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>                  <span class="at">mrna =</span> <span class="fu">seq</span>(<span class="dv">10</span>, <span class="dv">18</span>, <span class="dv">2</span>))</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>                   </span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a><span class="co"># run the feature selection tuning</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>tune.miRNA_plsda <span class="ot">=</span> <span class="fu">tune.splsda</span>( training_data<span class="sc">$</span>miRNA, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> perf.diablo_miRNA_plsda<span class="sc">$</span>choice.ncomp[<span class="st">"BER"</span>,<span class="st">"centroids.dist"</span>], </span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>                              <span class="at">test.keepX =</span> test.keepX<span class="sc">$</span>mirna, </span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>                              <span class="at">validation =</span> <span class="st">'Mfold'</span>, <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">1</span>,</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>                              <span class="at">dist =</span> <span class="st">"centroids.dist"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Note that the number of components cannot be reliably tuned with nrepeat &lt; 3 or validaion = 'loo'.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>tune.mRNA_plsda <span class="ot">=</span> <span class="fu">tune.splsda</span>( training_data<span class="sc">$</span>mRNA, <span class="at">Y =</span> Y_training, <span class="at">ncomp =</span> perf.diablo_mRNA_plsda<span class="sc">$</span>choice.ncomp[<span class="st">"BER"</span>,<span class="st">"centroids.dist"</span>], </span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">test.keepX =</span> test.keepX<span class="sc">$</span>mrna, </span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>                              <span class="at">validation =</span> <span class="st">'Mfold'</span>, <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">1</span>,</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>                              <span class="at">dist =</span> <span class="st">"centroids.dist"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Note that the number of components cannot be reliably tuned with nrepeat &lt; 3 or validaion = 'loo'.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>final_miRNA_plsda <span class="ot">&lt;-</span> <span class="fu">splsda</span>(training_data<span class="sc">$</span>miRNA,Y_training,<span class="at">ncomp =</span> perf.diablo_miRNA_plsda<span class="sc">$</span>choice.ncomp[<span class="st">"BER"</span>,<span class="st">"centroids.dist"</span>],<span class="at">keepX =</span> tune.miRNA_plsda<span class="sc">$</span>choice.keepX)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>perf.diablo_miRNA_plsda <span class="ot">=</span> <span class="fu">perf</span>(final_miRNA_plsda, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>final_mRNA_plsda <span class="ot">&lt;-</span> <span class="fu">splsda</span>(training_data<span class="sc">$</span>mRNA,Y_training,<span class="at">ncomp =</span> perf.diablo_mRNA_plsda<span class="sc">$</span>choice.ncomp[<span class="st">"BER"</span>,<span class="st">"centroids.dist"</span>],<span class="at">keepX =</span> tune.mRNA_plsda<span class="sc">$</span>choice.keepX)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>perf.diablo_mRNA_plsda <span class="ot">=</span> <span class="fu">perf</span>(final_mRNA_plsda, <span class="at">validation =</span> <span class="st">'Mfold'</span>, </span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">folds =</span> <span class="dv">10</span>, <span class="at">nrepeat =</span> <span class="dv">10</span>)</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Erro rates for Integrated analysis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Erro rates for Integrated analysis"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>perf.diablo<span class="sc">$</span>WeightedPredict.error.rate[<span class="st">"Overall.BER"</span>,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     comp1      comp2      comp3 
0.33333333 0.08814815 0.07866667 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Erro rates for miRNA analysis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Erro rates for miRNA analysis"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>perf.diablo_miRNA_plsda<span class="sc">$</span>error.rate<span class="sc">$</span>BER[,<span class="st">"centroids.dist"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    comp1     comp2 
0.2589630 0.2152593 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Erro rates for mRNA analysis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Erro rates for mRNA analysis"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>perf.diablo_mRNA_plsda<span class="sc">$</span>error.rate<span class="sc">$</span>BER[,<span class="st">"centroids.dist"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     comp1      comp2      comp3 
0.09303704 0.08074074 0.08600000 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Prediction on the test set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Prediction on the test set"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>predicted_class_test <span class="ot">&lt;-</span> <span class="fu">predict</span>(final_miRNA_plsda,test_data<span class="sc">$</span>miRNA)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>pred_classes_test<span class="ot">&lt;-</span>predicted_class_test<span class="sc">$</span>class<span class="sc">$</span>centroids.dist[,final_miRNA_plsda<span class="sc">$</span>ncomp]</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>readl_classes_test <span class="ot">&lt;-</span> breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>subtype</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a confusion matrix</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="ot">&lt;-</span> <span class="fu">table</span>(readl_classes_test, pred_classes_test)</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the class error rates</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>class_error <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">diag</span>(conf_matrix) <span class="sc">/</span> <span class="fu">rowSums</span>(conf_matrix)</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the overall error rate</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>overall_error_rate <span class="ot">&lt;-</span> (<span class="fu">sum</span>(conf_matrix) <span class="sc">-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(conf_matrix))) <span class="sc">/</span> <span class="fu">sum</span>(conf_matrix)</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"miRNA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "miRNA"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"BER:"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "BER:"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">mean</span>(class_error))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.168254</code></pre>
</div>
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Overall"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Overall"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(overall_error_rate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.1857143</code></pre>
</div>
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="do">#######</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>predicted_class_test <span class="ot">&lt;-</span> <span class="fu">predict</span>(final_mRNA_plsda,test_data<span class="sc">$</span>mRNA)</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>pred_classes_test<span class="ot">&lt;-</span>predicted_class_test<span class="sc">$</span>class<span class="sc">$</span>centroids.dist[,final_mRNA_plsda<span class="sc">$</span>ncomp]</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>readl_classes_test <span class="ot">&lt;-</span> breast.TCGA<span class="sc">$</span>data.test<span class="sc">$</span>subtype</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a confusion matrix</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="ot">&lt;-</span> <span class="fu">table</span>(readl_classes_test, pred_classes_test)</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the class error rates</span></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>class_error <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">diag</span>(conf_matrix) <span class="sc">/</span> <span class="fu">rowSums</span>(conf_matrix)</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the overall error rate</span></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>overall_error_rate <span class="ot">&lt;-</span> (<span class="fu">sum</span>(conf_matrix) <span class="sc">-</span> <span class="fu">sum</span>(<span class="fu">diag</span>(conf_matrix))) <span class="sc">/</span> <span class="fu">sum</span>(conf_matrix)</span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"miRNA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "miRNA"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"BER:"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "BER:"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">mean</span>(class_error))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.03492063</code></pre>
</div>
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="st">"Overall"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Overall"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(overall_error_rate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.04285714</code></pre>
</div>
</div>
<p>What do you think? Did the integration improve anything?</p>
</section>
</section>
</section>
<section id="integrative-regression" class="level2">
<h2 class="anchored" data-anchor-id="integrative-regression">Integrative regression</h2>
<p>The regression-based integrative analysis can also be performed as demonstrated above. However, unfortunately mixOmics does not provide functions to perform cross-validation and tuning on <code>block.pls</code> results. Most of the required measurements can be implement from scratch but we are going to skip it as it goes beyond the purpose of this document.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>